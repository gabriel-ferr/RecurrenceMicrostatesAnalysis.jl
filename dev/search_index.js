var documenterSearchIndex = {"docs":
[{"location":"tutorial/recurrences/#Recurrence-Functions","page":"Recurrence Functions","title":"Recurrence Functions","text":"","category":"section"},{"location":"tutorial/recurrences/#RecurrenceMicrostatesAnalysis.RecurrenceExpression","page":"Recurrence Functions","title":"RecurrenceMicrostatesAnalysis.RecurrenceExpression","text":"RecurrenceExpression\n\n\n\n\n\n","category":"type"},{"location":"tutorial/utils/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"tutorial/utils/#Optimizing-the-threshold","page":"Utils","title":"Optimizing the threshold","text":"","category":"section"},{"location":"tutorial/utils/#RecurrenceMicrostatesAnalysis.optimize","page":"Utils","title":"RecurrenceMicrostatesAnalysis.optimize","text":"optimize(param::Parameter, qm::QuantificationMeasure, args...)\n\n\n\n\n\n","category":"function"},{"location":"tutorial/quantifiers/#Quantifiers","page":"Quantifiers","title":"Quantifiers","text":"Quantifiers are measures used to characterize specific properties of a system.  Currently, RMA provides five quantifiers that can be computed or estimated from a microstate distribution.  Three of them are estimations of classical Recurrence Quantification Analysis (RQA) measures: recurrence rate, determinism, and laminarity.  One corresponds to an information-theoretic entropy.  And, the final quantifier is the disorder measure, which is defined using the microstate distribution as the basis for applying the method.\n\nIn this section, we describe each of these quantifiers and explain how to compute them using the RecurrenceMicrostatesAnalysis.jl package.\n\nAll quantifiers implemented in the package inherit from QuantificationMeasure, and their computation is performed using the measure function.","category":"section"},{"location":"tutorial/quantifiers/#Recurrence-microstates-entropy","page":"Quantifiers","title":"Recurrence microstates entropy","text":"The recurrence microstates entropy (RME) was introduced in 2018 and marks the beginning of the RMA framework (Corso et al., 2018). It is defined as the Shannon entropy of the RMA distribution:\n\nRME = -sum_i = 1^2^sigma p_i^(n) ln p_i^(n)\n\nwhere n is the microstate length, sigma is the number of recurrence elements constrained within microstate (e.g., sigma = n^2 for square microstates), and p_i^(n) denotes the probability of the microstate with decimal representation i in the distribution.\n\nIn RecurrenceMicrostatesAnalysis.jl, the RME is implemented by the RecurrenceEntropy struct.\n\nSince the output of the distribution function is a Probabilities object, the package also supports other information or complexity measures, provided by the package ComplexityMeasures.jl.","category":"section"},{"location":"tutorial/quantifiers/#Recurrence-rate","page":"Quantifiers","title":"Recurrence rate","text":"The recurrence rate quantifies the proportion of black points in a recurrence plot, serving as a measure of the relative density of recurrence points in the sparse recurrence matrix (Webber and Marwan, 2015). In standard RQA, it is defined as\n\nRR = frac1K^2 sum_ij=1^K R_ij\n\nWhen estimated using RMA, the recurrence rate is defined as the expected value of the recurrence rate over the microstate distribution:\n\nRR = sum_i = 1^2^sigma p_i^(n) RR_i^(n)\n\nwhere RR_i^(n) denotes the recurrence rate of the i-th microstate. For square microstates, this quantity is given by\n\nRR_i^(n) = frac1sigma sum_mn=1^n M_mn^i (n)\n\nwhere mathbf M_i^(n) represents the structure of the microstate identified by the decimal index i, with size n, for a given motif shape (in this case, square).\n\nIn RecurrenceMicrostatesAnalysis.jl, this quantifier is implemented by the RecurrenceRate struct.","category":"section"},{"location":"tutorial/quantifiers/#Determinism","page":"Quantifiers","title":"Determinism","text":"In standard RQA, determinism (DET) is defined as the fraction of recurrence points that form diagonal line structures in the recurrence plot (Webber and Marwan, 2015):\n\nDET = fracsum_l=d_min^K lH_D(l)sum_ij=1^N R_ij\n\nwhere H_D(l) denotes the histogram of diagonal line lengths in the RP, given by\n\nH_D(l)=sum_ij1^N(1-R_i-1j-1)(1-R_i+lj+l)prod_k=0^l-1R_i+kj+k\n\nThe estimation of DET using RMA is based on the work \"Density-Based Recurrence Measures from Microstates\" (da¬†Cruz et al., 2025). In that work, the DET expression is rewritten as\n\nDET = 1 - frac1N^2RRsum_l=1^l_min-1 lH_D(l)\n\nand the diagonal histogram H_D(l) is related to the RMA distribution through correlations between microstate structures:\n\nfracH_D(l)(N-l-1)^2=vec d^(l)cdotmathcalR^(l+2)vec p^(l+2)\n\nFor the commonly used case l_min = 2 (currently the only case implemented in the package), this leads to the approximation\n\nDETapprox 1 - fracvec d^(1)cdotmathcalR^(3)vec p^3RR\n\nThe correlation term vec d^(1)cdotmathcalR^(3)vec p^3 can be simplified by explicitly identifying the microstates selected by vec d^(1). These correspond to microstates of the form\n\nbeginpmatrix\nxi  xi  0 \nxi  1  xi \n0  xi  xi \nendpmatrix\n\nwhere xi denotes an unconstrained entry. There are 64 such microstates among the 512 possible square microstates of size n = 3.  Defining the class C_D as the set of microstates with this structure, DET can be estimated as:\n\nDETapprox 1 - fracsum_iin C_D p_i^(3)RR\n\nwhere p_i^(3) is the probability of the i-th microstate in an RMA distribution of square microstates with size n = 3.\n\nA futher simplification can be obtained by defining Diagonal-shaped microstates (Ferreira et al., 2025).  In the structure above, the unconstrained entries xi may represent either recurrences or non-recurrences, leading to the need for all 64 combinations. Diagonal microstates focus directly on the relevant information, namely the diagonal pattern 010. In this case, DET can be approximated as\n\nDETapprox 1 - fracp_3^(3)RR\n\nwhere p_3^(3) is the probability of observing the diagonal motif 010.\n\nIn RecurrenceMicrostatesAnalysis.jl, the computation of DET is implemented by the Determinism struct.","category":"section"},{"location":"tutorial/quantifiers/#Laminarity","page":"Quantifiers","title":"Laminarity","text":"Laminarity (LAM) is another classical RQA quantifier that measures the proportion of recurrence points forming vertical (line) structures in a recurrence plot.  It is defined as\n\nLAM = fracsum_l=v_min^K lH_V(l)sum_ij=1^N R_ij\n\nwhere\n\nH_V(l)=sum_ij1^N(1-R_ij-1)(1-R_ij+l)prod_k=0^l-1R_ij+k\n\nThe estimation of LAM using RMA is also based on the work \"Density-Based Recurrence Measures from Microstates\" (da¬†Cruz et al., 2025) and follows the same logical used for determinsm. In this case, the estimation requires microstates of the form\n\nbeginpmatrix\n0  1  0 \nxi  xi  xi \nxi  xi  xi \nendpmatrix\n\nwhich defines the class C_L of microstates used to estimate LAM as\n\nLAMapprox 1 - fracsum_iin C_L p_i^(3)RR\n\nAs with determinism, this process can be further simplified by defining a line motif (Ferreira et al., 2025), which captures only the relevant information, namely vertical line patterns of the form 010 in the recurrence plot. In this case, LAM can be approximated as\n\nLAMapprox 1 - fracp_3^(3)RR\n\nwhere p_3^(3) denotes the probability of observing the line motif 010.\n\nIn RecurrenceMicrostatesAnalysis.jl, the computation of LAM is implemented by the Laminarity struct.","category":"section"},{"location":"tutorial/quantifiers/#Disorder","page":"Quantifiers","title":"Disorder","text":"The disorder quantifier is implemented based on the work ‚ÄúQuantifying Disorder in Data‚Äù (Flauzino et al., 2025).  It is a novel and powerful tool for data analysis, allowing the differentiation between stochastic and deterministic time series, as well as between different types of stochastic dynamics, such as white, pink, and red Gaussian noise.\n\nDisorder is implemented using square recurrence microstates, which can be permuted by rows and columns and transposed (see Permutations and Transposition).  This procedure generates a set of equivalent microstates given by\n\nmathcalM_a(mathbfM) = bigcup_sigma_isigma_jin S_NmathcalL_sigma_jmathcalTmathcalL_sigma_imathbfMquadmathcalTmathcalL_sigma_jmathcalTmathcalL_sigma_imathbfM\n\nThis defines an equivalence class of microstates denoted by mathcalM_a.\n\nThe probability of observing a given microstate mathbf M_i^(n) in the recurrence plot, denoted by p_i^(n), is computed using RecurrenceMicrostatesAnalysis.jl. To compute disorder, the probabilities of microstates belonging to the same class must be normalized. Thus, for mathbf M_i^(n) in mathcalM_a, the normalized probability within the class is defined as\n\np_i^(a n) = fracp_i^(n)sum_mathbfM_j^(n) in mathcalM_ap_j^(n)\n\nThe information entropy associated with the probability distribution of microstates in the class mathcalM_a is then defined as\n\nxi_a(varepsilon) stackrelmathrmdef= -sum_mathbfM_i^(n) in mathcalM_a p_i^(a n) ln p_i^(a n)\n\nThis entropy is normalized by ln m_a, where m_a is the number of microstates in the class mathcalM_a. Using RecurrenceMicrostatesAnalysis.jl, the normalized quantity xi_a(varepsilon)  ln m_a can be computed as\n\nusing Distributions, RecurrenceMicrostatesAnalysis\ndata = StateSpaceSet(rand(Uniform(0, 1), 1000))\ndist = distribution(data, 0.27, 4; sampling = Full())\n\nclass = 102\nmeasure(Disorder(4), class, dist)\n\nThe total entropy over all classes for a given threshold varepsilon is defined as\n\nxi(varepsilon) stackrelmathrmdef= frac1A sum_a = 1^A fracxi_a(varepsilon)ln m_a\n\nwhere A is the number of contributing classes and defines the maximum possible amplitude. This normalization factor can also be computed using RecurrenceMicrostatesAnalysis.jl:\n\nA = RecurrenceMicrostatesAnalysis.get_disorder_norm_factor(Disorder(4), data)\n\nAnd the total entropy:\n\nmeasure(Disorder(4), dist, A)\n\nFinally, the the disorder index via symmetry in recurrence microstates (DISREM), or simply disorder, is defined as\n\nXi = max_varepsilon xi(varepsilon)\n\nIn RecurrenceMicrostatesAnalysis.jl, this quantifier is implemented by the Disorder struct.","category":"section"},{"location":"tutorial/quantifiers/#Computing-disorder-for-compatible-time-series","page":"Quantifiers","title":"Computing disorder for compatible time series","text":"Consider a scenario in which a long time series is split into multiple windows. RecurrenceMicrostatesAnalysis.jl provides a compact interface to compute the disorder for each window.\n\nAs an example, consider a time series with 50,000 points consisting of a sine wave with added white noise, alternating every five windows:\n\nfunction data_gen(t)\n    x = sin.(6*œÄ .* t)\n\n    count = 0\n    for i in 1:1000:50_000\n        if count < 5\n            x[i:(i-1)+1000] .+= rand(Normal(0, 0.25), 1000)\n        elseif count ‚â• 9\n            count = -1\n        end\n\n        count += 1\n    end\n\n    return x\nend\n\nusing CairoMakie\n\nt = range(0, 50, 50_000)\ndata = data_gen(t)\n\nlines(t, data)\n\nThe disorder can be computed using the following method:\n\nmeasure(settings::Disorder{N}, dataset::Vector{StateSpaceSet}, th_min::Float64, th_max::Float64)\n\nTo apply it, the time series must first be split into a vector of StateSpaceSet objects:\n\nwindows = [ data[(i + 1):(i + 1000)] for i in 0:1000:(length(data) - 1000)]\ndataset = Vector{StateSpaceSet}(undef, length(windows))\nfor i ‚àà eachindex(windows)\n    dataset[i] = StateSpaceSet(windows[i])\nend\n\ndataset\n\nNext, the threshold range th_min and th_max must be defined. There are two possible approaches:\n\nUse the full range of admissible threshold values by setting th_min = 0 and th_max = maximum(pairwise(Euclidean(), data, data)), and choosing a small step size via the num_tests keywork argument (e.g., num_tests = 1000). This approach yields the global maximum disorder values but can be computationally expensive.\nUse a small interval centered around a known threshold value. This is the recommended approach and is adopted here.\n\nTo obtain a suitable reference threshold, we select a subset of windows and compute the optimal disorder threshold using the optimize function:\n\nusing Statistics\n\nfunction find_threshold(disorder, data)\n    ths = zeros(Float64, 10)\n    for i ‚àà eachindex(ths)\n        idx = rand(1:length(windows))\n        ths[i] = optimize(Threshold(), disorder, data[idx])[1]\n    end\n\n    Œº = mean(ths)\n    œÉ = std(ths)\n\n    return (max(0.0, Œº - 1.5 * œÉ), Œº + 1.5 * œÉ)\nend\n\ndis = Disorder(4)\nth_min, th_max = find_threshold(dis, dataset)\n\nFinally, the disorder can be computed for all windows using the measure function:\n\nresults = measure(dis, dataset, th_min, th_max)\n\nscatterlines(results)\n\ntip: Tip\nDisorder can also be computed using the GPU backend:measure(settings::Disorder{N}, dataset::Vector{<:AbstractGPUVector{SVector{D, Float32}}}, th_min::Float32, th_max::Float32)The procedure is identical, but each window must first be transferred to the GPU:for i ‚àà eachindex(windows)\n    dataset[i] = StateSpaceSet(Float32.(windows[i])) |> CuVector\nend","category":"section"},{"location":"tutorial/quantifiers/#RecurrenceMicrostatesAnalysis.QuantificationMeasure","page":"Quantifiers","title":"RecurrenceMicrostatesAnalysis.QuantificationMeasure","text":"QuantificationMeasure\n\nAbstract supertype defining an RQA or RMA quantification measure.   All quantifiers implemented in the package inherit from this type and define their computation through the measure function.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/quantifiers/#RecurrenceMicrostatesAnalysis.measure","page":"Quantifiers","title":"RecurrenceMicrostatesAnalysis.measure","text":"measure(qm::QuantificationMeasure, [...])\n\nCompute the quantifier defined by the given QuantificationMeasure instance.   Each implementation may accept different parameters ([...]), depending on the specific quantifier.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/quantifiers/#RecurrenceMicrostatesAnalysis.RecurrenceEntropy","page":"Quantifiers","title":"RecurrenceMicrostatesAnalysis.RecurrenceEntropy","text":"RecurrenceEntropy <: QuantificationMeasure\n\nDefines the Recurrence Microstates Entropy (RME) quantification measure.\n\nThe computation of RME is performed using the measure function, for which two implementations are provided.\n\nUsing a distribution\n\nmeasure(::RecurrenceEntropy, dist::Probabilities)\n\nInput\n\nThe QuantificationMeasure.\ndist: a distribution of recurrence microstates.\n\nOutput\n\nReturns a Float64 corresponding to the RME computed using the Shannon entropy.\n\nExamples\n\nusing RecurrenceMicrostatesAnalysis, Distributions\ndata = StateSpaceSet(rand(Uniform(0, 1), 1000))\ndist = distribution(data, 0.27, 3)\nrme = measure(RecurrenceEntropy(), dist)\n\nUsing a time series\n\nmeasure(::RecurrenceEntropy, [x]; kwargs...)\n\nInput\n\nThe QuantificationMeasure.\n[x]: time-series provided as an StateSpaceSet.\n\nOutput\n\nReturns a Float64 corresponding to the maximum RME based on the Shannon Entropy.\n\nKeyword arguments\n\nn: an Integer defining the microstates size. The default value is 3.\n\nExamples\n\nusing RecurrenceMicrostatesAnalysis, Distributions\ndata = StateSpaceSet(rand(Uniform(0, 1), 1000))\nrme = measure(RecurrenceEntropy(), data; n = 4)\n\n\n\n\n\n","category":"type"},{"location":"tutorial/quantifiers/#RecurrenceMicrostatesAnalysis.RecurrenceRate","page":"Quantifiers","title":"RecurrenceMicrostatesAnalysis.RecurrenceRate","text":"RecurrenceRate <: QuantificationMeasure\n\nDefines the Recurrence Rate (RR) quantification measure.  The computation of RR is performed using the measure function, for which two implementations are provided.\n\nUsing a distribution\n\nmeasure(::RecurrenceRate, dist::Probabilities)\n\nInput\n\nThe QuantificationMeasure.\ndist: a distribution of recurrence microstates.\n\nOutput\n\nReturns a Float64 corresponding to the estimated Recurrence Rate.\n\nExamples\n\nusing RecurrenceMicrostatesAnalysis, Distributions\ndata = StateSpaceSet(rand(Uniform(0, 1), 1000))\ndist = distribution(data, 0.27, 3)\nrr = measure(RecurrenceRate(), dist)\n\nUsing a time series\n\nmeasure(::RecurrenceRate, [x]; kwargs...)\n\nInput\n\nThe QuantificationMeasure.\n[x]: time-series data provided as a StateSpaceSet.\n\nOutput\n\nReturns a Float64 corresponding to the estimated Recurrence Rate.\n\nKeyword arguments\n\nn: an Integer which defines the microstates size. The default value is 3.\nthreshold: threshold used to compute the RMA distribution. By default, this is the threshold that maximizes the RME.\n\nExamples\n\nusing RecurrenceMicrostatesAnalysis, Distributions\ndata = StateSpaceSet(rand(Uniform(0, 1), 1000))\nrme = measure(RecurrenceRate(), data; n = 4)\n\n\n\n\n\n","category":"type"},{"location":"tutorial/quantifiers/#RecurrenceMicrostatesAnalysis.Determinism","page":"Quantifiers","title":"RecurrenceMicrostatesAnalysis.Determinism","text":"Determinism <: QuantificationMeasure\n\nDefines the Determinism (DET) quantification measure.  The computation of DET is performed using the measure function, for which two implementations are provided.\n\nUsing a distribution\n\nmeasure(::Determinism, dist::Probabilities)\n\nInput\n\nThe QuantificationMeasure.\ndist: a distribution of recurrence microstates. The distribution must be computed from square or diagonal microstates with size 3.\n\nOutput\n\nReturns a Float64 corresponding to the estimated determinism.\n\nExamples\n\nUsing square microstates:\n\nusing RecurrenceMicrostatesAnalysis, Distributions\ndata = StateSpaceSet(rand(Uniform(0, 1), 1000))\ndist = distribution(data, 0.27, 3)\ndet = measure(Determinism(), dist)\n\nUsing diagonal microstates:\n\nusing RecurrenceMicrostatesAnalysis, Distributions\ndata = StateSpaceSet(rand(Uniform(0, 1), 1000))\ndist = distribution(data, Diagonal(Standard(0.27), 3))\ndet = measure(Determinism(), dist)\n\nUsing a time series\n\nmeasure(::Determinism, [x]; kwargs...)\n\nInput\n\nThe QuantificationMeasure.\n[x]: time-series data provided as a StateSpaceSet.\n\nOutput\n\nReturns a Float64 corresponding to the estimated determinism.\n\nKeyword arguments\n\nthreshold: threshold used to compute the RMA distribution. By default, this is the threshold that maximizes the RME.\n\nExamples\n\nusing RecurrenceMicrostatesAnalysis, Distributions\ndata = StateSpaceSet(rand(Uniform(0, 1), 1000))\ndet = measure(Determinism(), data)\n\nnote: Note\nWhen a time series is provided as input, RecurrenceMicrostatesAnalysis.jl uses Diagonal microstates by default.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/quantifiers/#RecurrenceMicrostatesAnalysis.Laminarity","page":"Quantifiers","title":"RecurrenceMicrostatesAnalysis.Laminarity","text":"Laminarity <: QuantificationMeasure\n\nDefines the Laminarity (LAM) quantification measure. The computation of LAM is performed using the measure function, for which two implementations are provided.\n\nUsing a distribution\n\nmeasure(::Laminarity, dist::Probabilities)\n\nInput\n\nThe QuantificationMeasure.\ndist: a distribution of recurrence microstates. The distribution must be computed from square or line microstates with size 3.\n\nOutput\n\nReturns a Float64 corresponding to the estimated laminarity.\n\nExamples\n\nUsing square microstates:\n\nusing RecurrenceMicrostatesAnalysis, Distributions\ndata = StateSpaceSet(rand(Uniform(0, 1), 1000))\ndist = distribution(data, 0.27, 3)\nlam = measure(Laminarity(), dist)\n\nUsing line microstates:\n\nusing RecurrenceMicrostatesAnalysis, Distributions\ndata = StateSpaceSet(rand(Uniform(0, 1), 1000))\ndist = distribution(data, Rect(Standard(0.27); rows = 1, cols = 3))\nlam = measure(Laminarity(), dist)\n\nUsing a time series\n\nmeasure(::Laminarity, [x]; kwargs...)\n\nInput\n\nThe QuantificationMeasure.\n[x]: time-series data provided as a StateSpaceSet.\n\nOutput\n\nReturns a Float64 corresponding to the estimated laminarity.\n\nKeyword arguments\n\nthreshold: threshold used to compute the RMA distribution. By default, this is the threshold that maximizes the RME.\n\nExamples\n\nusing RecurrenceMicrostatesAnalysis, Distributions\ndata = StateSpaceSet(rand(Uniform(0, 1), 1000))\nlam = measure(Laminarity(), data)\n\nnote: Note\nWhen a time series is provided as input, RecurrenceMicrostatesAnalysis.jl uses line microstates by default.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/quantifiers/#RecurrenceMicrostatesAnalysis.Disorder","page":"Quantifiers","title":"RecurrenceMicrostatesAnalysis.Disorder","text":"Disorder{N} <: QuantificationMeasure\n\nDefines the Disorder quantifier for microstates of size N. The structure contains the labels, which identify the microstates belonging to each equivalence class mathcalM_a.\n\nTo initialize the Disorder struct, use:\n\nDisorder(N)\n\nHere, N must be equal to 2, 3, 4, or 5. Computing disorder for large values of N is currently not supported, as it would require a prohibitive amount of computational memory with the current implementation.\n\nThe computation of Disorder is performed using the measure function:\n\nmeasure(settings::Disorder{N}, [x]; kwargs...)\n\nInput\n\nThe QuantificationMeasure.\n[x]: time-series data provided as a StateSpaceSet.\n\nOutput\n\nReturns a Float64 corresponding to the disorder value (Xi).\n\nKeyword arguments\n\nth: threshold value used to maximize disorder. To improve computational performance, this parameter defines a reference value that limits the search range of thresholds. By default, it is set to the threshold that maximizes disorder for a sampling rate of 5.\nth_min: minimum threshold value defining the search range. By default, this is set to 0.85 * th.\nth_max: maximum threshold value defining the search range. By default, this is set to 1.25 * th.\nnum_tests: number of threshold values evaluated within the specified range. The default value is 40.\n\nExamples\n\nusing RecurrenceMicrostatesAnalysis, Distributions\ndata = StateSpaceSet(rand(Uniform(0, 1), 1000))\ndisrem = measure(Disorder(4), data)\n\n\n\n\n\n","category":"type"},{"location":"dev/#RecurrenceMicrostatesAnalysis.jl-for-Devs","page":"Developers","title":"RecurrenceMicrostatesAnalysis.jl for Devs","text":"","category":"section"},{"location":"dev/#RecurrenceMicrostatesAnalysis.RMACore","page":"Developers","title":"RecurrenceMicrostatesAnalysis.RMACore","text":"RMACore\n\n\n\n\n\n","category":"type"},{"location":"dev/#RecurrenceMicrostatesAnalysis.CPUCore","page":"Developers","title":"RecurrenceMicrostatesAnalysis.CPUCore","text":"CPUCore{M<:MotifShape, S<:SamplingMode}\n\n\n\n\n\n","category":"type"},{"location":"dev/#RecurrenceMicrostatesAnalysis.GPUCore","page":"Developers","title":"RecurrenceMicrostatesAnalysis.GPUCore","text":"GPUCore\n\n\n\n\n\n","category":"type"},{"location":"dev/#RecurrenceMicrostatesAnalysis.StandardCPUCore","page":"Developers","title":"RecurrenceMicrostatesAnalysis.StandardCPUCore","text":"StandardCPUCore{M<:MotifShape, S<:SamplingMode} <: CPUCore{M, S}\n\n\n\n\n\n","category":"type"},{"location":"dev/#RecurrenceMicrostatesAnalysis.StandardGPUCore","page":"Developers","title":"RecurrenceMicrostatesAnalysis.StandardGPUCore","text":"StandardGPUCore{B, M<:MotifShape, S<:SamplingMode} <: GPUCore{B, M, S}\n\n\n\n\n\n","category":"type"},{"location":"refs/#References","page":"References","title":"References","text":"Corso,¬†G.; Lima Prado,¬†T.; Santos Lima,¬†G.¬†Z.; Kurths,¬†J. and Lopes,¬†S.¬†R. (2018). Quantifying entropy using recurrence matrix microstates. Chaos 28.\n\n\n\nda¬†Cruz,¬†F.¬†E.; Prado,¬†T.¬†d.; Lopes,¬†S.¬†R.; Marwan,¬†N. and Kurths,¬†J. (2025). Density-based recurrence measures from microstates. Phys.¬†Rev.¬†E 111, 044212.\n\n\n\nEckmann,¬†J.-P.; Kamphorst,¬†S.¬†O. and Ruelle,¬†D. (1987). Recurrence Plots of Dynamical Systems. EUROPHYSICS¬†LETTERS¬†Europhys.¬†Lett 4, 973.\n\n\n\nFerreira,¬†G.¬†V.; Cruz,¬†F.¬†E.; Marghoti,¬†G.; Lima Prado,¬†T.; Lopes,¬†S.¬†R.; Marwan,¬†N. and Kurths,¬†J. (2025). RecurrenceMicrostatesAnalysis.jl: A Julia library for analyzing dynamical systems with recurrence microstates. Chaos 35.\n\n\n\nFlauzino,¬†J.¬†V.; Prado,¬†T.¬†L.; Marwan,¬†N.; Kurths,¬†J. and Lopes,¬†S.¬†R. (2025). Quantifying Disorder in Data. Physical¬†Review¬†Letters 135, 097401.\n\n\n\nMarwan,¬†N.; Kurths,¬†J. and Saparin,¬†P. (2007). Generalised Recurrence Plot Analysis for Spatial Data. Physics¬†Letters¬†A 360, 545‚Äì551.\n\n\n\nWebber,¬†C.¬†L. and Marwan,¬†N. (2015). Recurrence Quantification Analysis: Theory and Best Practices (Springer, Cham, Switzerland).\n\n\n\n","category":"section"},{"location":"tutorial/distributions/#Distributions","page":"Distributions","title":"Distributions","text":"In this section, we introduce the computation of Recurrence Microstates Analysis (RMA) distributions using RecurrenceMicrostatesAnalysis.jl. We begin with a Quick start with RecurrenceMicrostatesAnalysis.jl, which demonstrates a simple application example. Next, we present A brief review of Recurrence Plots (RP) and RMA. Finally, we explain the distribution function in Computing RMA distributions, describing how to use it, as well as the computation of Histograms.","category":"section"},{"location":"tutorial/distributions/#Quick-start-with-RecurrenceMicrostatesAnalysis.jl","page":"Distributions","title":"Quick start with RecurrenceMicrostatesAnalysis.jl","text":"Here we present quick examples of how to use the package. To compute an RMA distribution, you need to use the distribution function, which returns a Probabilities struct containing the microstate distribution.\n\nWe start with a simple example by computing the distribution of a uniform random process. First, we generate the data and convert it into a StateSpaceSet:\n\nusing Distributions, RecurrenceMicrostatesAnalysis\ndata = rand(Uniform(0, 1), 10_000);\nssset = StateSpaceSet(data)\n\nNext, we use this StateSpaceSet as input to compute the distribuion. We also need to specify the threshold, varepsilon, and the microstate length, N. These parameters are explained in more detail in the sections A brief review and Optimizing the threshold.\n\nWe will do here a \"fast example about how to use the package\". To compute a RMA distribution with the package you need to use the function distribution, which will result in a Probabilities struct containg the distribution of microstates.\n\nŒµ = 0.27\nN = 2\ndist = distribution(ssset, Œµ, N)\n\nAs another example, we use the package DynamicalSystems.jl. Following the same H√©non map example presented in its documentation, we compute a trajectory as follows:\n\nusing DynamicalSystems\n\nfunction henon_rule(u, p, n) # here `n` is \"time\", but we don't use it.\n    x, y = u # system state\n    a, b = p # system parameters\n    xn = 1.0 - a*x^2 + y\n    yn = b*x\n    return SVector(xn, yn)\nend\n\nu0 = [0.2, 0.3]\np0 = [1.4, 0.3]\n\nhenon = DeterministicIteratedMap(henon_rule, u0, p0)\n\ntotal_time = 10_000\nX, t = trajectory(henon, total_time)\nX\n\nFinally, we compute the RMA distribution from the trajectory X. Here, we use the optimize function to determine an appropriate threshold by maximizing the recurrence entropy:\n\nŒµ, S = optimize(Threshold(), RecurrenceEntropy(), X, N)\n\ndist = distribution(X, Œµ, N)","category":"section"},{"location":"tutorial/distributions/#A-brief-review","page":"Distributions","title":"A brief review","text":"The concept of Recurrence Plots (RPs) was introduced in 1987 by Eckmann et al. (Eckmann et al., 1987) as a method for analyzing dynamical systems through recurrences. Let a time series vec x_i in mathbbR^d, i in 1 2  K where K is the length of the time series and d is the dimension of the phase space (e.g., d = 3 for the Lorenz system). The RP is defined as a graphical representation of the recurrence matrix\n\nR_ij = Theta(varepsilon - vec x_i - vec x_j)\n\nwhere Theta(cdot) denotes the Heaviside step function and varepsilon is the threshold parameter that defines the maximum distance between two points for them to be considered varepsilon-recurrent.\n\nThe following figure shows examples of recurrence plots for different systems: (a) white noise; (b) a superposition of harmonic oscillators; (c) a logistic map, x_n+1 = 4x_n(1 - x_n), with a linear trend added in time, y_n = x_n + alpha n; (d) Brownian motion.\n\n(Image: Image of four RPs with their timeseries)\n\nA recurrence microstate is a small local structure that can be identified within an RP. These structures form a closed set of microstates, determined by their shape and size. For example, considering square microstates of length N = 2, there are 16 possible microstates that can occur in an RP.\n\n(Image: Image of the 16 squared microstates to N = 2)\n\nRecurrence Microstates Analysis (RMA) uses the probability distribution of these microstates within an RP as a source of information for the analysis.  Accordingly, RecurrenceMicrostatesAnalysis.jl computes these distributions and applies them to the study of dynamical systems.","category":"section"},{"location":"tutorial/distributions/#Computing-RMA-distributions","page":"Distributions","title":"Computing RMA distributions","text":"The computation of RMA distributions is the core of the RecurrenceMicrostatesAnalysis.jl package; all other functionalities rely on it as their primary source of information. Therefore, understanding how this tool works is essential in order to fully use the package and all that it has to offer.  RMA distributions are computed using the distribution function, which provides several parameters that control its behaviour.\n\nThe package implements several aliases to simplify the usage of the distribution function. One of them was shown in the Quick start with RecurrenceMicrostatesAnalysis.jl section:\n\ndistribution([x], Œµ::Float, n::Int; kwargs...)\n\nThis method automatically uses a CPUCore when [x] is a StateSpaceSet, or a GPUCore when [x] is an AbstractGPUVector. By default, it also uses Square microstates with side length n.\n\nIn addition to the keyword arguments of the default implementation, this method provides the following extra configurations:\n\nrate::Float64: sampling rate, with default value 0.05.\nsampling::SamplingMode: sampling mode; see Distribution sampling. The default is SRandom.\nmetric::Metric: metric used to compute recurrences, based on the package Distances.jl. When using a GPUCore, a GPUMetric must be used; see Metrics for GPU.\n\nwarning: Warning\nWhen using GPU backend, inputs must be of type Float32. The package is not compatible with Float64 on GPU.\n\nIt is also possible to specify the RecurrenceExpression directly instead of providing the threshold explicitly:\n\ndistribution([x], expr::RecurrenceExpression, n::Int; kwargs...)\n\nIn this case, the keyword arguments remain the same, except for metric, which is already defined within the RecurrenceExpression.\n\nExample:\n\nexpr = Corridor(0.05, 0.27)\ndist = distribution(ssset, expr, 2)\n\nIf a different MotifShape is desired, the function call can be simplified to:\n\ndistribution([x], shape::MotifShape; kwargs...)\n\nHere, shape constains the information about both the RecurrenceExpression and the microstate size n.\n\nExample:\n\nshape = Triangle(Standard(0.27), 3)\ndist = distribution(ssset, shape)\n\nThe package also provides implementations for computing RMA distributions from Cross-Recurrence Plots (CRPs).  In this case, the workflow is similar, but two time series must be provided as input:\n\ndistribution([x], [y], expr::RecurrenceExpression, n::Int; kwargs...)\ndistribution([x], [y], expr::RecurrenceExpression, n::Int; kwargs...)\ndistribution([x], [y], shape::MotifShape; kwargs...)\n\nExample:\n\ndata_1 = StateSpaceSet(rand(Uniform(0, 1), 1000))\ndata_2 = StateSpaceSet(rand(Uniform(0, 1), 2000))\ndist = distribution(data_1, data_2, 0.27, 2)\n\ndanger: Danger\nNote that [x] and [y] must have the same phase-space dimensionality. The following example is invalid because data_1 has 2 dimensions while data_2 has 3, which results in an exception:data_1 = StateSpaceSet(rand(Uniform(0, 1), (1000, 2)))\ndata_2 = StateSpaceSet(rand(Uniform(0, 1), (2000, 3)))\ndist = distribution(data_1, data_2, 0.27, 2)","category":"section"},{"location":"tutorial/distributions/#Spatial-data","page":"Distributions","title":"Spatial data","text":"RecurrenceMicrostatesAnalysis.jl also provides support for spatial data, following the work \"Generalised Recurrence Plot Analysis for Spatial Data\" (Marwan et al., 2007). This implementation represents an open research direction and is included in the package primarily for exploratory purposes. For this reason, support for spatial data analysis is partial, as many of its theoretical aspects have not yet been fully developed.\n\nIn this context, the application interface is\n\ndistribution([x], shape::MotifShape; kwargs...)\n\nwhich was introduced earlier. The implementation is the same, but here [x] is an AbstractArray. The input data are defined as\n\nvecx_vec i in mathbbR^m veci in mathbbZ^d\n\nWithin the package context, this can be provided as, for example, m = 2, d = 2, and veci in 1 K^d with K = 50:\n\nspatialdata = rand(Uniform(0, 1), (2, 50, 50))\n\nThe resulting recurrence plot has dimension 2 times d, forming a tensorial structure that cannot be directly visualized and can be computationally demanding. In this situation, the RMA distribution can be defined to avoid memory limitations, although the cost of increased complexity. Specifically, the microstates may themselves become tensorial objects of dimension 2 times d, or projections onto lower-dimensional subspaces. This bevaviour is specified through the MotifShape.\n\nExample:\n\nMicrostate with N = 2 and full 2 times d dimensionality:\n\ndistribution(spatialdata, Rect(Standard(0.27), (2, 2, 2, 2)))\n\nMicrostate with N = 2 projected onto the first and third dimensions:\n\ndistribution(spatialdata, Rect(Standard(0.27), (2, 1, 2, 1)))\n\nRecurrenceMicrostatesAnalysis.jl also supports a spatial analogue of the Cross-Recurrence Plot (CRP) used for time series, referred to here as the Croos-Spatial Recurrence Plot (CSRP). This functionality arises naturally from the package structure and can be invoked as\n\ndistribution([x], [y], shape::MotifShape; kwargs...)\n\nExample:\n\nMicrostate N = 2 and full 2times d dimensionality:\n\nspatialdata_1 = rand(Uniform(0, 1), (2, 50, 50))\nspatialdata_2 = rand(Uniform(0, 1), (2, 25, 25))\ndistribution(spatialdata_1, spatialdata_2, Rect(Standard(0.27), (2, 2, 2, 2)))\n\nMicrostate N = 2 projected onto the first and third dimensions:\n\ndistribution(spatialdata_1, spatialdata_2, Rect(Standard(0.27), (2, 1, 2, 1)))","category":"section"},{"location":"tutorial/distributions/#Histograms","page":"Distributions","title":"Histograms","text":"The histogram function is responsible for counting the occurrences of each microstate identified during the sampling process.  It is internally called by the distribution function, which takes the resulting Counts and returns the corresponding Probabilities.\n\nThis function is also responsible for implementing the backend.","category":"section"},{"location":"tutorial/distributions/#RecurrenceMicrostatesAnalysis.distribution","page":"Distributions","title":"RecurrenceMicrostatesAnalysis.distribution","text":"distribution(core::RMACore, [x], [y])\n\nCompute an RMA distribution from a recurrence structure constructed using the input data [x] and [y].   If [x] and [y] are identical, the result corresponds to a Recurrence Plot (RP); otherwise, it corresponds to a Cross-Recurrence Plot (CRP).\n\nThe core argument must be a structure inheriting from RMACore and defines how the computation is performed, including whether a CPU or GPU backend is used, the microstate shape, the recurrence expression, and the sampling mode.\n\nThe output of distribution is a Probabilities object, where each index corresponds to the decimal representation of the associated microstate.\n\n\n\n\n\ndistribution(core::CPUCore, [x], [y]; kwargs...)\n\nComputes an RMA distribution using [x] and [y] as input and a CPU backend configuration specified by core, which must be a CPUCore.  The inputs [x] and [y] must be provided as StateSpaceSet objects for time-series data, or as AbstractArrays for spatial data.\n\nInput\n\ncore: A CPUCore defining the configuration of the MotifShape, RecurrenceExpression, and SamplingMode.\n[x]: Input data, given as a StateSpaceSet or an AbstractArray.\n[y]: Input data, given as a StateSpaceSet or an AbstractArray.\n\nKeyword Arguments\n\nthreads: Number of threads which used to compute the distribution. By default, this is set to Threads.nthreads(), which can be specified at Julia startup using ‚Äì using --threads N or via the environment variable JULIA_NUM_THREADS.\n\nExamples\n\nTime series:\n\ncore = CPUCore(Rect(Standard(0.27), 2), SRandom(0.05))\ndist = distribution(core, ssset, ssset)\n\nSpatial data:\n\nspatialdata = rand(Uniform(0, 1), (3, 50, 50))\ncore = CPUCore(Rect(Standard(0.5), (2, 2, 1, 1)), SRandom(0.05))\ndist = distribution(core, spatialdata, spatialdata)\n\n\n\n\n\ndistribution(core::GPUCore, [x], [y]; kwargs...)\n\nCompute an RMA distribution using [x] and [y] as input data and a GPU backend configuration specified by core, which must be a GPUCore.   The inputs [x] and [y] must be vectors inheriting from AbstractGPUVector. This method supports only time-series analysis.\n\nnote: Note\nThe output is copied from GPU memory back to the CPU.\n\nInput\n\ncore: A GPUCore defining the configuration of the MotifShape, RecurrenceExpression, and SamplingMode.\n[x]: Input data, provided as an AbstractGPUVector.\n[y]: Input data, provided as an AbstractGPUVector.\n\nKwargs\n\ngroupsize: Number of threads per workgroup on the GPU device.\n\nExamples\n\nusing CUDA\ngpudata = StateSpaceSet(Float32.(data)) |> CuVector\ncore = GPUCore(CUDABackend(), Rect(Standard(0.27f0; metric = GPUEuclidean()), 2), SRandom(0.05))\ndist = distribution(core, gpudata, gpudata)\n\nwarning: Warning\nSpatial data are not supported by GPUCore.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/distributions/#RecurrenceMicrostatesAnalysis.histogram","page":"Distributions","title":"RecurrenceMicrostatesAnalysis.histogram","text":"histogram(core::RMACore, [x], [y])\n\nCompute the histogram of recurrence microstates using the input data [x] and [y] for a given core, which must be an RMACore.   This function implements the backend, executing the sampling process, constructing the microstates, and computing the recurrences.\n\nThe output is a Counts object, where each index corresponds to the decimal representation of the associated microstate.\n\n\n\n\n\nhistogram(core::StandardCPUCore, [x], [y]; kwargs...)\n\nCount the microstates of an \"abstract\" RP constructed using [x] and [y]. If [x] and [y] are identical, the result corresponds to a Recurrence Plot (RP); otherwise, it corresponds to a Cross-Recurrence Plot (CRP). The output is a histogram of recurrence microstates for the given input data as a Counts structure.\n\nThis method implements the CPU backend, based on a CPUCore, specifically a StandardCPUCore.\n\nInput\n\ncore: A StandardCPUCore, which defines how the backend computation is performed.\n[x]: Input data, provided as a StateSpaceSet or an AbstractArray.\n[y]: Input data, provided as a StateSpaceSet or an AbstractArray.\n\nnote: Note\nStateSpaceSet and AbstractArray use different backends and therefore different internal histogram implementations.   However, both functions share the same method signature, differing only in the input data format.\n\nKeyword Arguments\n\nthreads: Number of threads used to compute the histogram. By default, this is set to Threads.nthreads(), which can be specified at Julia startup using ‚Äì using --threads N or via the environment variable JULIA_NUM_THREADS.\n\nExamples\n\nTime series:\n\ncore = CPUCore(Rect(Standard(0.27), 2), SRandom(0.05))\ndist = histogram(core, ssset, ssset)\n\nSpatial data:\n\nspatialdata = rand(Uniform(0, 1), (3, 50, 50))\ncore = CPUCore(Rect(Standard(0.5), (2, 2, 1, 1)), SRandom(0.05))\ndist = histogram(core, spatialdata, spatialdata)\n\n\n\n\n\nhistogram(core::StandardGPUCore, [x], [y]; kwargs...)\n\nCount the microstates of an \"abstract\" RP constructed using [x] and [y]. If [x] and [y] are identical, the result corresponds to a Recurrence Plot (RP); otherwise, it corresponds to a Cross-Recurrence Plot (CRP). The output is a histogram of recurrence microstates for the given input data as a Counts structure.\n\nnote: Note\nThe output is copied from GPU memory back to the CPU.\n\nThis method implements the GPU backend, based on a GPUCore, specifically a StandardGPUCore.\n\nInput\n\ncore: A StandardGPUCore, which defines how the backend computation is performed.\n[x]: Input data, provided as an AbstractGPUVector.\n[y]: Input data, provided as an AbstractGPUVector.\n\nKeyword Arguments\n\ngroupsize: Number of threads per workgroup on the GPU device.\n\nExamples\n\nusing CUDA\ngpudata = StateSpaceSet(Float32.(data)) |> CuVector\ncore = GPUCore(CUDABackend(), Rect(Standard(0.27f0; metric = GPUEuclidean()), 2), SRandom(0.05))\ndist = histogram(core, gpudata, gpudata)\n\n\n\n\n\n","category":"function"},{"location":"tutorial/gpu/#GPU","page":"GPU","title":"GPU","text":"","category":"section"},{"location":"tutorial/gpu/#Metrics-for-GPU","page":"GPU","title":"Metrics for GPU","text":"","category":"section"},{"location":"tutorial/gpu/#RecurrenceMicrostatesAnalysis.GPUMetric","page":"GPU","title":"RecurrenceMicrostatesAnalysis.GPUMetric","text":"GPUMetric <: Metric\n\n\n\n\n\n","category":"type"},{"location":"tutorial/tips/#Performance-Tips","page":"Performance Tips","title":"Performance Tips","text":"","category":"section"},{"location":"examples/ml/#RMA-with-Machine-Learning","page":"Machine Learning","title":"RMA with Machine Learning","text":"","category":"section"},{"location":"tutorial/shapes_and_sampling/#Shapes-and-Sampling","page":"Shapes and Sampling","title":"Shapes and Sampling","text":"","category":"section"},{"location":"tutorial/shapes_and_sampling/#Variations-of-Microstates-shapes","page":"Shapes and Sampling","title":"Variations of Microstates shapes","text":"","category":"section"},{"location":"tutorial/shapes_and_sampling/#Distribution-sampling","page":"Shapes and Sampling","title":"Distribution sampling","text":"","category":"section"},{"location":"tutorial/shapes_and_sampling/#RecurrenceMicrostatesAnalysis.MotifShape","page":"Shapes and Sampling","title":"RecurrenceMicrostatesAnalysis.MotifShape","text":"MotifShape\n\n\n\n\n\n","category":"type"},{"location":"tutorial/shapes_and_sampling/#RecurrenceMicrostatesAnalysis.Diagonal","page":"Shapes and Sampling","title":"RecurrenceMicrostatesAnalysis.Diagonal","text":"Diagonal{N, B, E<:RecurrenceExpression} <: MotifShape\n\n\n\n\n\n","category":"type"},{"location":"tutorial/shapes_and_sampling/#RecurrenceMicrostatesAnalysis.SamplingMode","page":"Shapes and Sampling","title":"RecurrenceMicrostatesAnalysis.SamplingMode","text":"SamplingMode\n\n\n\n\n\n","category":"type"},{"location":"tutorial/shapes_and_sampling/#RecurrenceMicrostatesAnalysis.SRandom","page":"Shapes and Sampling","title":"RecurrenceMicrostatesAnalysis.SRandom","text":"SRandom{F<:Real} <: SamplingMode\n\n\n\n\n\n","category":"type"},{"location":"tutorial/operations/#Operations","page":"Operations","title":"Operations","text":"","category":"section"},{"location":"tutorial/operations/#Permutations-and-Transposition","page":"Operations","title":"Permutations and Transposition","text":"","category":"section"},{"location":"#RecurrenceMicrostatesAnalysis.jl","page":"Welcome","title":"RecurrenceMicrostatesAnalysis.jl","text":"todo: GitHub\nRecurrenceMicrostatesAnalysis.jl is an open-source package available on GitHub. If you find this package useful, please consider giving it a star on GitHub and don't forget to cite our work. üòâ","category":"section"},{"location":"#About-the-documentation","page":"Welcome","title":"About the documentation","text":"RecurrenceMicrostatesAnalysis.jl documentation was designed to explain how to use the package while also introducing the theoretical background of the RMA field. The bibliography used is listed in the References section; remember to cite the appropriate works if you use them.\n\nWe begin this welcome section by introducing the Input data for RecurrenceMicrostatesAnalysis.jl. It is very important to understand the data types used by the package and their purposes before continuing with the rest of the documentation. We also describe the Output data from RecurrenceMicrostatesAnalysis.jl, explaining the type of data returned by the package when computing distributions of recurrence microstates.\n\nthe Tutorial section explains how to use the package. We start with a brief introduction to the RMA framework and show how to compute Distributions using RecurrenceMicrostatesAnalysis.jl. Next, we demonstate how to estimate RQA Quantifiers using RMA and discuss several quantifiers defined specifically for RMA. This material forms the \"basic level\" of the documentation and is sufficient to learn how to use the package effectively. We also include an introduction to Operations with recurrence microstates.\n\nIf you want to learn more about RecurrenceMicrostatesAnalysis.jl, the Recurrence Functions section discusses variations in computing recurrence between two states, and the Shapes and Sampling section provides explanations about different motif shapes, which are used to extract specific information from an abstract Recurrence Plot.\n\nWe also provide a pipeline for GPU computations, which we recommend reading if you intend to use this framework. Moreover, the Performance Tips section offers advice on improving the performance of RecurrenceMicrostatesAnalysis.jl and avoiding common pitfalls.\n\nThis documentation also includes some sections with applied examples:\n\nRMA with Machine Learning\n\nFinally, if you are a developer interested in contributing to RecurrenceMicrostatesAnalysis.jl, we recommend reading the section RecurrenceMicrostatesAnalysis.jl for Devs.","category":"section"},{"location":"#Input-data-for-RecurrenceMicrostatesAnalysis.jl","page":"Welcome","title":"Input data for RecurrenceMicrostatesAnalysis.jl","text":"RecurrenceMicrostatesAnalysis.jl accepts two types of input (each of them with a different backend):\n\nStateSpaceSet ‚Äî used for multivariate time series, datasets, or state-space sets. It is employed by the backend when working with Recurrence Plots (RP) or Cross-Recurrence Plots (CRP). If you are working with RP or CRP, we strongly recommend using this data type, since the backend is optimized for it in this context.\nAbstractArray{<: Real} ‚Äî used for spatial data. This allows RMA to be applied in the generalized framework of Spatial Recurrence Plots (SRP) (Marwan et al., 2007). If you provide a Matrix, this input type can also be used instead of a StateSpaceSet; however, we do not recommend it, as the backend for AbstractArray{<: Real} is heavier and incompatible with some features.\nAbstractGPUVector - used for analysis of time series using the GPU backend. We explain how it works better in the section GPU.\n\nwarning: Warning\nRMA with SRP is an open research field. We include this functionality in the package for exploratory purposes, but the method is not yet mature enough for production use. Nevertheless, feel free to experiment with it in your research. üòÉ","category":"section"},{"location":"#Output-data-from-RecurrenceMicrostatesAnalysis.jl","page":"Welcome","title":"Output data from RecurrenceMicrostatesAnalysis.jl","text":"When computing the RMA distribution, RecurrenceMicrostatesAnalysis.jl returns a Probabilities structure. This type is provided by ComplexityMeasures.jl, allowing this package to interoperate naturally with its tools and workflows.","category":"section"},{"location":"#RecurrenceMicrostatesAnalysis","page":"Welcome","title":"RecurrenceMicrostatesAnalysis","text":"RecurrenceMicrostatesAnalysis.jl\n\n(Image: Package Downloads) (Image: Publication)\n\nRecurrenceMicrostatesAnalysis.jl is a simple and fast Julia-based package for recurrence microstates analysis. It implements the computation of Recurrence Microstates Analysis (RMA) distributions, specific quantifiers ‚Äî such as disorder ‚Äî and the estimation of typical RQA quantifiers, including determinism and laminarity.\n\nRMA is a subfield of Recurrence Analysis and is a powerful tool for analyzing large time series or large datasets using statistical methods, offering high performance and avoiding memory issues. Although the field is still relatively new, it has shown promising applications, including in Machine Learning.\n\nThe package was redesigned in version 0.4.0 to be compatible with DynamicalSystems ecosystem. We therefore recommend exploring the other packages in this ecosystem ‚Äî expecially ComplexityMeasures.jl and RecurrenceAnalysis.jl ‚Äî which can be very useful when working with RMA.\n\nTo install the package, run:\n\nimport Pkg\nPkg.add(\"RecurrenceMicrostatesAnalysis\")\n\nThe package documentation is available online, or you can build it locally by running julia docs/make.jl.\n\n\n\n\n\n","category":"module"},{"location":"#StateSpaceSets.StateSpaceSet","page":"Welcome","title":"StateSpaceSets.StateSpaceSet","text":"StateSpaceSet{D, T, V} <: AbstractVector{V}\n\nA dedicated interface for sets in a state space. It is an ordered container of equally-sized points of length D, with element type T, represented by a vector of type V. Typically V is SVector{D,T} or Vector{T} and the data are always stored internally as Vector{V}. SSSet is an alias for StateSpaceSet.\n\nThe underlying Vector{V} can be obtained by vec(ssset), although this is almost never necessary because StateSpaceSet subtypes AbstractVector and extends its interface. StateSpaceSet also supports almost all sensible vector operations like append!, push!, hcat, eachrow, among others. When iterated over, it iterates over its contained points.\n\nConstruction\n\nConstructing a StateSpaceSet is done in three ways:\n\nBy giving in each individual columns of the state space set as Vector{<:Real}: StateSpaceSet(x, y, z, ...).\nBy giving in a matrix whose rows are the state space points: StateSpaceSet(m).\nBy giving in directly a vector of vectors (state space points): StateSpaceSet(v_of_v).\n\nAll constructors allow for two keywords:\n\ncontainer which sets the type of V (the type of inner vectors). At the moment options are only SVector, MVector, or Vector, and by default SVector is used.\nnames which can be an iterable of length D whose elements are Symbols. This allows assigning a name to each dimension and accessing the dimension by name, see below. names is nothing if not given. Use StateSpaceSet(s; names) to add names to an existing set s.\n\nDescription of indexing\n\nWhen indexed with 1 index, StateSpaceSet behaves exactly like its encapsulated vector. i.e., a vector of vectors (state space points). When indexed with 2 indices it behaves like a matrix where each row is a point.\n\nIn the following let i, j be integers, typeof(X) <: AbstractStateSpaceSet and v1, v2 be <: AbstractVector{Int} (v1, v2 could also be ranges, and for performance benefits make v2 an SVector{Int}).\n\nX[i] == X[i, :] gives the ith point (returns an SVector)\nX[v1] == X[v1, :], returns a StateSpaceSet with the points in those indices.\nX[:, j] gives the jth variable timeseries (or collection), as Vector\nX[v1, v2], X[:, v2] returns a StateSpaceSet with the appropriate entries (first indices being \"time\"/point index, while second being variables)\nX[i, j] value of the jth variable, at the ith timepoint\n\nIn all examples above, j can also be a Symbol, provided that names has been given when creating the state space set. This allows accessing a dimension by name. This is provided as a convenience and it is not an optimized operation, hence recommended to be used primarily with X[:, j::Symbol].\n\nUse Matrix(ssset) or StateSpaceSet(matrix) to convert. It is assumed that each column of the matrix is one variable. If you have various timeseries vectors x, y, z, ... pass them like StateSpaceSet(x, y, z, ...). You can use columns(dataset) to obtain the reverse, i.e. all columns of the dataset in a tuple.\n\n\n\n\n\n","category":"type"},{"location":"#ComplexityMeasures.Probabilities","page":"Welcome","title":"ComplexityMeasures.Probabilities","text":"Probabilities <: Array{<:AbstractFloat, N}\nProbabilities(probs::Array [, outcomes [, dimlabels]]) ‚Üí p\nProbabilities(counts::Counts [, outcomes [, dimlabels]]) ‚Üí p\n\nProbabilities stores an N-dimensional array of probabilities, while ensuring that the array sums to 1 (normalized probability mass). In most cases the array is a standard vector. p itself can be manipulated and iterated over, just like its stored array.\n\nThe probabilities correspond to outcomes that describe the axes of the array. If p isa Probabilities, then p.outcomes[i] is an an abstract vector containing the outcomes along the i-th dimension. The outcomes have the same ordering as the probabilities, so that p[i][j] is the probability for outcome p.outcomes[i][j]. The dimensions of the array are named, and can be accessed by p.dimlabels, where p.dimlabels[i] is the label of the i-th dimension. Both outcomes and dimlabels are assigned automatically if not given. If the input is a set of Counts, and outcomes and dimlabels are not given, then the labels and outcomes are inherited from the counts.\n\nExamples\n\njulia> probs = [0.2, 0.2, 0.2, 0.2]; Probabilities(probs) # will be normalized to sum to 1\n Probabilities{Float64,1} over 4 outcomes\n Outcome(1)  0.25\n Outcome(2)  0.25\n Outcome(3)  0.25\n Outcome(4)  0.25\n\njulia> c = Counts([12, 16, 12], [\"out1\", \"out2\", \"out3\"]); Probabilities(c)\n Probabilities{Float64,1} over 3 outcomes\n \"out1\"  0.3\n \"out2\"  0.4\n \"out3\"  0.3\n\n\n\n\n\n","category":"type"},{"location":"#ComplexityMeasures.Counts","page":"Welcome","title":"ComplexityMeasures.Counts","text":"Counts <: Array{<:Integer, N}\nCounts(counts [, outcomes [, dimlabels]]) ‚Üí c\n\nCounts stores an N-dimensional array of integer counts corresponding to a set of outcomes. This is typically called a \"frequency table\" or \"contingency table\".\n\nIf c isa Counts, then c.outcomes[i] is an abstract vector containing the outcomes along the i-th dimension, where c[i][j] is the count corresponding to the outcome c.outcomes[i][j], and c.dimlabels[i] is the label of the i-th dimension. Both labels and outcomes are assigned automatically if not given. c itself can be manipulated and iterated over like its stored array.\n\n\n\n\n\n","category":"type"}]
}
