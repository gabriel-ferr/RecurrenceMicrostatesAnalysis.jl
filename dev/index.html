<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Welcome ¬∑ RecurrenceMicrostatesAnalysis.jl</title><meta name="title" content="Welcome ¬∑ RecurrenceMicrostatesAnalysis.jl"/><meta property="og:title" content="Welcome ¬∑ RecurrenceMicrostatesAnalysis.jl"/><meta property="twitter:title" content="Welcome ¬∑ RecurrenceMicrostatesAnalysis.jl"/><meta name="description" content="Documentation for RecurrenceMicrostatesAnalysis.jl."/><meta property="og:description" content="Documentation for RecurrenceMicrostatesAnalysis.jl."/><meta property="twitter:description" content="Documentation for RecurrenceMicrostatesAnalysis.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>RecurrenceMicrostatesAnalysis.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Welcome</a><ul class="internal"><li><a class="tocitem" href="#About-the-documentation"><span>About the documentation</span></a></li><li><a class="tocitem" href="#Input-data-for-RecurrenceMicrostatesAnalysis.jl"><span>Input data for RecurrenceMicrostatesAnalysis.jl</span></a></li><li><a class="tocitem" href="#Output-data-from-RecurrenceMicrostatesAnalysis.jl"><span>Output data from RecurrenceMicrostatesAnalysis.jl</span></a></li></ul></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="tutorial/distributions/">Distributions</a></li><li><a class="tocitem" href="tutorial/quantifiers/">Quantifiers</a></li><li><a class="tocitem" href="tutorial/recurrences/">Recurrence Functions</a></li><li><a class="tocitem" href="tutorial/shapes_and_sampling/">Shapes and Sampling</a></li><li><a class="tocitem" href="tutorial/gpu/">GPU</a></li><li><a class="tocitem" href="tutorial/utils/">Utils</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="examples/ml/">Machine Learning</a></li></ul></li><li><a class="tocitem" href="dev/">Developers</a></li><li><a class="tocitem" href="refs/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Welcome</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Welcome</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="RecurrenceMicrostatesAnalysis.jl"><a class="docs-heading-anchor" href="#RecurrenceMicrostatesAnalysis.jl">RecurrenceMicrostatesAnalysis.jl</a><a id="RecurrenceMicrostatesAnalysis.jl-1"></a><a class="docs-heading-anchor-permalink" href="#RecurrenceMicrostatesAnalysis.jl" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis"><code>RecurrenceMicrostatesAnalysis</code></a> ‚Äî <span class="docstring-category">Module</span></summary><section><div><p><strong>RecurrenceMicrostatesAnalysis.jl</strong></p><p><a href="http://juliapkgstats.com/pkg/RecurrenceMicrostatesAnalysis"><img src="https://img.shields.io/badge/dynamic/json?url=http%3A%2F%2Fjuliapkgstats.com%2Fapi%2Fv1%2Ftotal_downloads%2FRecurrenceMicrostatesAnalysis&amp;query=total_requests&amp;label=Downloads" alt="Package Downloads"/></a> <a href="https://doi.org/10.1063/5.0293708"><img src="https://img.shields.io/badge/publication-Chaos-blue.svg" alt="Publication"/></a></p><p><strong>RecurrenceMicrostatesAnalysis.jl</strong> is a simple and fast Julia-based package for recurrence microstates analysis. It implements the computation of Recurrence Microstates Analysis (RMA) distributions, specific quantifiers ‚Äî such as <a href="https://doi.org/10.1103/1y98-x33s">disorder</a> ‚Äî and the estimation of typical RQA quantifiers, including determinism and laminarity.</p><p>RMA is a subfield of Recurrence Analysis and is a powerful tool for analyzing large time series or large datasets using statistical methods, offering high performance and avoiding memory issues. Although the field is still relatively new, it has shown promising applications, including in <a href="https://doi.org/10.1063/5.0203801">Machine Learning</a>.</p><p>The package was redesigned in version <code>0.4.0</code> to be compatible with <a href="https://juliadynamics.github.io/DynamicalSystemsDocs.jl/dynamicalsystems/stable/">DynamicalSystems</a> ecosystem. We therefore recommend exploring the other packages in this ecosystem ‚Äî expecially <a href="https://juliadynamics.github.io/DynamicalSystemsDocs.jl/complexitymeasures/stable/">ComplexityMeasures.jl</a> and <a href="https://juliadynamics.github.io/DynamicalSystemsDocs.jl/recurrenceanalysis/stable/">RecurrenceAnalysis.jl</a> ‚Äî which can be very useful when working with RMA.</p><p>To install the package, run:</p><pre><code class="language-julia hljs">import Pkg
Pkg.add(&quot;RecurrenceMicrostatesAnalysis&quot;)</code></pre><p>The package documentation is available <a href="https://dynamicsufpr.github.io/RecurrenceMicrostatesAnalysis.jl/">online</a>, or you can build it locally by running <code>julia docs/make.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/ef56ed683e529e7a8bb8bf0472a4899ba712af62/src/RecurrenceMicrostatesAnalysis.jl#L3-L30">source</a></section></details></article><div class="admonition is-todo" id="GitHub-b4dbbf5a004afec3"><header class="admonition-header">GitHub<a class="admonition-anchor" href="#GitHub-b4dbbf5a004afec3" title="Permalink"></a></header><div class="admonition-body"><p>RecurrenceMicrostatesAnalysis.jl is an open-source package available on <a href="https://github.com/DynamicsUFPR/RecurrenceMicrostatesAnalysis.jl">GitHub</a>. If you find this package useful, please consider giving it a star on GitHub and don&#39;t forget to cite <a href="https://doi.org/10.1063/5.0293708">our work</a>. üòâ</p></div></div><h2 id="About-the-documentation"><a class="docs-heading-anchor" href="#About-the-documentation">About the documentation</a><a id="About-the-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#About-the-documentation" title="Permalink"></a></h2><p>The documentation of <strong>RecurrenceMicrostatesAnalysis.jl</strong> is designed to explain how to use the package while also introducing the theoretical background of the RMA framework. The bibliography used throughout the documentation is listed in the <a href="refs/#References">References</a> section; <strong>please remember to cite the appropriate works if you use them</strong>.</p><p>This welcome section begins with an introduction to the <a href="#Input-data-for-RecurrenceMicrostatesAnalysis.jl">Input data for RecurrenceMicrostatesAnalysis.jl</a>. Understanding the data types used by the package and their intended purposes is essential before proceeding with the rest of the documentation. We also describe the <a href="#Output-data-from-RecurrenceMicrostatesAnalysis.jl">Output data from RecurrenceMicrostatesAnalysis.jl</a>, explaining the type of data returned when computing recurrence microstate distributions.</p><p>The <strong>Tutorial</strong> section explains how to use the package in practice. It starts with a brief introduction to RMA and demonstrates how to compute <a href="tutorial/distributions/#Distributions">Distributions</a> using <strong>RecurrenceMicrostatesAnalysis.jl</strong>. Next, we show how to estimate RQA <a href="tutorial/quantifiers/#Quantifiers">Quantifiers</a> using RMA and discuss several quantifiers defined specifically for RMA. This material constitutes the <em>basic level</em> of the documentation and is sufficient to use the package effectively.</p><p>For users interested in more advanced topics, the <a href="tutorial/recurrences/#Recurrence-Functions">Recurrence Functions</a> section discusses different ways of computing recurrence between two states, while the <a href="tutorial/shapes_and_sampling/#Shapes-and-Sampling">Shapes and Sampling</a> section explains motif shapes used to extract specific information from a Recurrence Plot.</p><p>We also provide a pipeline for <a href="tutorial/gpu/#GPU">GPU</a> computations, which we recommend reading if you plan to use the GPU backend.</p><p>The documentation includes applied examples, such as:</p><ul><li><a href="examples/ml/#RMA-with-Machine-Learning">RMA with Machine Learning</a></li></ul><p>Finally, developers interested in contributing to RecurrenceMicrostatesAnalysis.jl are encouraged to read the <a href="dev/#RecurrenceMicrostatesAnalysis.jl-for-Devs">RecurrenceMicrostatesAnalysis.jl for Devs</a> section.</p><h2 id="Input-data-for-RecurrenceMicrostatesAnalysis.jl"><a class="docs-heading-anchor" href="#Input-data-for-RecurrenceMicrostatesAnalysis.jl">Input data for RecurrenceMicrostatesAnalysis.jl</a><a id="Input-data-for-RecurrenceMicrostatesAnalysis.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Input-data-for-RecurrenceMicrostatesAnalysis.jl" title="Permalink"></a></h2><p><strong>RecurrenceMicrostatesAnalysis.jl</strong> accepts three types of input, each associated with a different backend:</p><ul><li><p><a href="#StateSpaceSets.StateSpaceSet"><code>StateSpaceSet</code></a> ‚Äî used for multivariate time series, datasets, or state-space representations. This type is employed when working with Recurrence Plots (RP) or Cross-Recurrence Plots (CRP). For RP and CRP analyses, we strongly recommend using this data type, as the backend is optimized for this context.</p></li><li><p><code>AbstractArray{&lt;: Real}</code> ‚Äî used for spatial data, enabling RMA to be applied within the generalized framework of Spatial Recurrence Plots (SRP) (<a href="refs/#Marwan2007Spatial">Marwan <em>et al.</em>, 2007</a>). Although a <code>Matrix</code> can be used as a substitute for a <a href="#StateSpaceSets.StateSpaceSet"><code>StateSpaceSet</code></a>, this is <strong>not recommended</strong>, since the <code>AbstractArray</code> backend is heavier and incompatible with some features.</p></li><li><p><code>AbstractGPUVector</code> ‚Äî used for time series analysis with the GPU backend. A better explanation is provided in the <a href="tutorial/gpu/#GPU">GPU</a> and <a href="tutorial/distributions/#Computing-RMA-distributions">Computing RMA distributions</a> sections.</p></li></ul><div class="admonition is-warning" id="Warning-b56a033f9ee4d2f"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-b56a033f9ee4d2f" title="Permalink"></a></header><div class="admonition-body"><p>RMA with SRP is an open research field. We include this functionality in the package for exploratory purposes, but the method is not yet mature enough for production use. Nevertheless, feel free to experiment with it in your research. üòÉ</p></div></div><article><details class="docstring" open="true"><summary id="StateSpaceSets.StateSpaceSet"><a class="docstring-binding" href="#StateSpaceSets.StateSpaceSet"><code>StateSpaceSets.StateSpaceSet</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">StateSpaceSet{D, T, V} &lt;: AbstractVector{V}</code></pre><p>A dedicated interface for sets in a state space. It is an <strong>ordered container of equally-sized points</strong> of length <code>D</code>, with element type <code>T</code>, represented by a vector of type <code>V</code>. Typically <code>V</code> is <code>SVector{D,T}</code> or <code>Vector{T}</code> and the data are always stored internally as <code>Vector{V}</code>. <code>SSSet</code> is an alias for <code>StateSpaceSet</code>.</p><p>The underlying <code>Vector{V}</code> can be obtained by <code>vec(ssset)</code>, although this is almost never necessary because <code>StateSpaceSet</code> subtypes <code>AbstractVector</code> and extends its interface. <code>StateSpaceSet</code> also supports almost all sensible vector operations like <code>append!, push!, hcat, eachrow</code>, among others. When iterated over, it iterates over its contained points.</p><p><strong>Construction</strong></p><p>Constructing a <code>StateSpaceSet</code> is done in three ways:</p><ol><li>By giving in each individual <strong>columns</strong> of the state space set as <code>Vector{&lt;:Real}</code>: <code>StateSpaceSet(x, y, z, ...)</code>.</li><li>By giving in a matrix whose rows are the state space points: <code>StateSpaceSet(m)</code>.</li><li>By giving in directly a vector of vectors (state space points): <code>StateSpaceSet(v_of_v)</code>.</li></ol><p>All constructors allow for two keywords:</p><ul><li><code>container</code> which sets the type of <code>V</code> (the type of inner vectors). At the moment options are only <code>SVector</code>, <code>MVector</code>, or <code>Vector</code>, and by default <code>SVector</code> is used.</li><li><code>names</code> which can be an iterable of length <code>D</code> whose elements are <code>Symbol</code>s. This allows assigning a name to each dimension and accessing the dimension by name, see below. <code>names</code> is <code>nothing</code> if not given. Use <code>StateSpaceSet(s; names)</code> to add names to an existing set <code>s</code>.</li></ul><p><strong>Description of indexing</strong></p><p>When indexed with 1 index, <code>StateSpaceSet</code> behaves exactly like its encapsulated vector. i.e., a vector of vectors (state space points). When indexed with 2 indices it behaves like a matrix where each row is a point.</p><p>In the following let <code>i, j</code> be integers, <code>typeof(X) &lt;: AbstractStateSpaceSet</code> and <code>v1, v2</code> be <code>&lt;: AbstractVector{Int}</code> (<code>v1, v2</code> could also be ranges, and for performance benefits make <code>v2</code> an <code>SVector{Int}</code>).</p><ul><li><code>X[i] == X[i, :]</code> gives the <code>i</code>th point (returns an <code>SVector</code>)</li><li><code>X[v1] == X[v1, :]</code>, returns a <code>StateSpaceSet</code> with the points in those indices.</li><li><code>X[:, j]</code> gives the <code>j</code>th variable timeseries (or collection), as <code>Vector</code></li><li><code>X[v1, v2], X[:, v2]</code> returns a <code>StateSpaceSet</code> with the appropriate entries (first indices being &quot;time&quot;/point index, while second being variables)</li><li><code>X[i, j]</code> value of the <code>j</code>th variable, at the <code>i</code>th timepoint</li></ul><p>In all examples above, <code>j</code> can also be a <code>Symbol</code>, provided that <code>names</code> has been given when creating the state space set. This allows accessing a dimension by name. This is provided as a convenience and it is not an optimized operation, hence recommended to be used primarily with <code>X[:, j::Symbol]</code>.</p><p>Use <code>Matrix(ssset)</code> or <code>StateSpaceSet(matrix)</code> to convert. It is assumed that each <em>column</em> of the <code>matrix</code> is one variable. If you have various timeseries vectors <code>x, y, z, ...</code> pass them like <code>StateSpaceSet(x, y, z, ...)</code>. You can use <code>columns(dataset)</code> to obtain the reverse, i.e. all columns of the dataset in a tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/v2.5.3/src/statespaceset_concrete.jl#L3-L63">source</a></section></details></article><h2 id="Output-data-from-RecurrenceMicrostatesAnalysis.jl"><a class="docs-heading-anchor" href="#Output-data-from-RecurrenceMicrostatesAnalysis.jl">Output data from RecurrenceMicrostatesAnalysis.jl</a><a id="Output-data-from-RecurrenceMicrostatesAnalysis.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Output-data-from-RecurrenceMicrostatesAnalysis.jl" title="Permalink"></a></h2><p>When computing the RMA distribution, RecurrenceMicrostatesAnalysis.jl returns a <a href="#ComplexityMeasures.Probabilities"><code>Probabilities</code></a> structure. This type is provided by <a href="https://juliadynamics.github.io/DynamicalSystemsDocs.jl/complexitymeasures/stable/">ComplexityMeasures.jl</a>, allowing this package to interoperate naturally with its tools and workflows.</p><article><details class="docstring" open="true"><summary id="ComplexityMeasures.Probabilities"><a class="docstring-binding" href="#ComplexityMeasures.Probabilities"><code>ComplexityMeasures.Probabilities</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Probabilities &lt;: Array{&lt;:AbstractFloat, N}
Probabilities(probs::Array [, outcomes [, dimlabels]]) ‚Üí p
Probabilities(counts::Counts [, outcomes [, dimlabels]]) ‚Üí p</code></pre><p><code>Probabilities</code> stores an <code>N</code>-dimensional array of probabilities, while ensuring that the array sums to 1 (normalized probability mass). In most cases the array is a standard vector. <code>p</code> itself can be manipulated and iterated over, just like its stored array.</p><p>The probabilities correspond to <code>outcomes</code> that describe the axes of the array. If <code>p isa Probabilities</code>, then <code>p.outcomes[i]</code> is an an abstract vector containing the outcomes along the <code>i</code>-th dimension. The outcomes have the same ordering as the probabilities, so that <code>p[i][j]</code> is the probability for outcome <code>p.outcomes[i][j]</code>. The dimensions of the array are named, and can be accessed by <code>p.dimlabels</code>, where <code>p.dimlabels[i]</code> is the label of the <code>i</code>-th dimension. Both <code>outcomes</code> and <code>dimlabels</code> are assigned automatically if not given. If the input is a set of <a href="#ComplexityMeasures.Counts"><code>Counts</code></a>, and <code>outcomes</code> and <code>dimlabels</code> are not given, then the labels and outcomes are inherited from the counts.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; probs = [0.2, 0.2, 0.2, 0.2]; Probabilities(probs) # will be normalized to sum to 1
 Probabilities{Float64,1} over 4 outcomes
 Outcome(1)  0.25
 Outcome(2)  0.25
 Outcome(3)  0.25
 Outcome(4)  0.25</code></pre><pre><code class="language-julia hljs">julia&gt; c = Counts([12, 16, 12], [&quot;out1&quot;, &quot;out2&quot;, &quot;out3&quot;]); Probabilities(c)
 Probabilities{Float64,1} over 3 outcomes
 &quot;out1&quot;  0.3
 &quot;out2&quot;  0.4
 &quot;out3&quot;  0.3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ComplexityMeasures.jl/blob/v3.8.5/src/core/probabilities.jl#L10-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ComplexityMeasures.Counts"><a class="docstring-binding" href="#ComplexityMeasures.Counts"><code>ComplexityMeasures.Counts</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Counts &lt;: Array{&lt;:Integer, N}
Counts(counts [, outcomes [, dimlabels]]) ‚Üí c</code></pre><p><code>Counts</code> stores an <code>N</code>-dimensional array of integer <code>counts</code> corresponding to a set of <code>outcomes</code>. This is typically called a &quot;frequency table&quot; or <a href="https://en.wikipedia.org/wiki/Contingency_table">&quot;contingency table&quot;</a>.</p><p>If <code>c isa Counts</code>, then <code>c.outcomes[i]</code> is an abstract vector containing the outcomes along the <code>i</code>-th dimension, where <code>c[i][j]</code> is the count corresponding to the outcome <code>c.outcomes[i][j]</code>, and <code>c.dimlabels[i]</code> is the label of the <code>i</code>-th dimension. Both labels and outcomes are assigned automatically if not given. <code>c</code> itself can be manipulated and iterated over like its stored array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/ComplexityMeasures.jl/blob/v3.8.5/src/core/counts.jl#L26-L39">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="tutorial/distributions/">Distributions ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 10 January 2026 18:18">Saturday 10 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
