<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Developers ¬∑ RecurrenceMicrostatesAnalysis.jl</title><meta name="title" content="Developers ¬∑ RecurrenceMicrostatesAnalysis.jl"/><meta property="og:title" content="Developers ¬∑ RecurrenceMicrostatesAnalysis.jl"/><meta property="twitter:title" content="Developers ¬∑ RecurrenceMicrostatesAnalysis.jl"/><meta name="description" content="Documentation for RecurrenceMicrostatesAnalysis.jl."/><meta property="og:description" content="Documentation for RecurrenceMicrostatesAnalysis.jl."/><meta property="twitter:description" content="Documentation for RecurrenceMicrostatesAnalysis.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">RecurrenceMicrostatesAnalysis.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Welcome</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../tutorial/distributions/">Distributions</a></li><li><a class="tocitem" href="../tutorial/quantifiers/">Quantifiers</a></li><li><a class="tocitem" href="../tutorial/recurrences/">Recurrence Functions</a></li><li><a class="tocitem" href="../tutorial/shapes_and_sampling/">Shapes and Sampling</a></li><li><a class="tocitem" href="../tutorial/gpu/">GPU</a></li><li><a class="tocitem" href="../tutorial/utils/">Utils</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/ml/">Machine Learning</a></li></ul></li><li class="is-active"><a class="tocitem" href>Developers</a><ul class="internal"><li><a class="tocitem" href="#RecurrenceMicrostatesAnalysis.jl-backend"><span>RecurrenceMicrostatesAnalysis.jl backend</span></a></li><li><a class="tocitem" href="#Adding-a-New-Recurrence-Function"><span>Adding a New Recurrence Function</span></a></li><li><a class="tocitem" href="#Adding-a-New-Sampling-Mode"><span>Adding a New Sampling Mode</span></a></li><li><a class="tocitem" href="#Adding-a-new-Microstate-Shape"><span>Adding a new Microstate Shape</span></a></li><li><a class="tocitem" href="#Adding-a-New-Quantifier"><span>Adding a New Quantifier</span></a></li><li><a class="tocitem" href="#Adding-a-New-GPU-Metric"><span>Adding a New GPU Metric</span></a></li></ul></li><li><a class="tocitem" href="../refs/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Developers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Developers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/main/docs/src/dev.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="RecurrenceMicrostatesAnalysis.jl-for-Devs"><a class="docs-heading-anchor" href="#RecurrenceMicrostatesAnalysis.jl-for-Devs">RecurrenceMicrostatesAnalysis.jl for Devs</a><a id="RecurrenceMicrostatesAnalysis.jl-for-Devs-1"></a><a class="docs-heading-anchor-permalink" href="#RecurrenceMicrostatesAnalysis.jl-for-Devs" title="Permalink"></a></h1><div class="admonition is-success" id="Tip-ff0741672c0fc24"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-ff0741672c0fc24" title="Permalink"></a></header><div class="admonition-body"><p>All pull requests that introduce new functionality must be thoroughly tested and documented. Tests are required only for methods that you extend. We recommend reading the <a href="https://github.com/JuliaDynamics/GoodScientificCodeWorkshop">Good Scientific Code Workshop</a>.</p><p>Always remember to add docstrings to your implementations, as well as tests to validate them.</p></div></div><h2 id="RecurrenceMicrostatesAnalysis.jl-backend"><a class="docs-heading-anchor" href="#RecurrenceMicrostatesAnalysis.jl-backend">RecurrenceMicrostatesAnalysis.jl backend</a><a id="RecurrenceMicrostatesAnalysis.jl-backend-1"></a><a class="docs-heading-anchor-permalink" href="#RecurrenceMicrostatesAnalysis.jl-backend" title="Permalink"></a></h2><p><strong>RecurrenceMicrostatesAnalysis.jl</strong> supports multiple backends, depending on the usage context. Each backend is implemented based on an <a href="#RecurrenceMicrostatesAnalysis.RMACore"><code>RMACore</code></a>, which defines how the package computes a <a href="../tutorial/distributions/#RecurrenceMicrostatesAnalysis.histogram"><code>histogram</code></a>.</p><p>There are two main backend implementations:</p><ul><li><a href="#RecurrenceMicrostatesAnalysis.CPUCore"><code>CPUCore</code></a>: defines how distributions are computed on the CPU. The default implementation is <a href="#RecurrenceMicrostatesAnalysis.StandardCPUCore"><code>StandardCPUCore</code></a>.</li><li><a href="#RecurrenceMicrostatesAnalysis.GPUCore"><code>GPUCore</code></a>: defines how distributions are computed on the GPU. The default implementation is <a href="#RecurrenceMicrostatesAnalysis.StandardGPUCore"><code>StandardGPUCore</code></a>.</li></ul><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis.RMACore"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis.RMACore"><code>RecurrenceMicrostatesAnalysis.RMACore</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RMACore</code></pre><p>Abstract supertype that defines the execution pipeline of the package.</p><p>An instance of <strong>RMACore</strong> must be provided to the <a href="../tutorial/distributions/#RecurrenceMicrostatesAnalysis.histogram"><code>histogram</code></a> function to determine how the histogram computation is performed.</p><p>Concrete implementations of <code>RMACore</code> are <a href="#RecurrenceMicrostatesAnalysis.CPUCore"><code>CPUCore</code></a> and <a href="#RecurrenceMicrostatesAnalysis.GPUCore"><code>GPUCore</code></a>, which target CPU and GPU execution, respectively. Implementing custom subtypes of <code>RMACore</code> is <strong>strongly discouraged</strong>, as doing so requires reimplementing several internal utilities for the package ecosystem to function correctly.</p><p><strong>Implementations</strong></p><ul><li><a href="#RecurrenceMicrostatesAnalysis.CPUCore"><code>CPUCore</code></a></li><li><a href="#RecurrenceMicrostatesAnalysis.GPUCore"><code>GPUCore</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/81a1514ebec215042ef88900dba26958abfbac3d/src/core/abstract_core.jl#L6-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis.CPUCore"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis.CPUCore"><code>RecurrenceMicrostatesAnalysis.CPUCore</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CPUCore{M&lt;:MicrostateShape, S&lt;:SamplingMode} &lt;: RMACore</code></pre><p>Abstract CPU backend that implements the <strong>RecurrenceMicrostatesAnalysis.jl</strong> execution pipeline on central processing units.</p><p>The package provides a default implementation via <a href="#RecurrenceMicrostatesAnalysis.StandardCPUCore"><code>StandardCPUCore</code></a>.</p><p>Concrete subtypes of <code>CPUCore</code> must define the following fields:</p><ul><li><code>shape</code>: the <a href="../tutorial/shapes_and_sampling/#RecurrenceMicrostatesAnalysis.MicrostateShape"><code>MicrostateShape</code></a> used to construct microstates.</li><li><code>sampling</code>: the <a href="../tutorial/shapes_and_sampling/#RecurrenceMicrostatesAnalysis.SamplingMode"><code>SamplingMode</code></a> used to sample the recurrence space.</li></ul><p><strong>Implementations</strong></p><ul><li><a href="#RecurrenceMicrostatesAnalysis.StandardCPUCore"><code>StandardCPUCore</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/81a1514ebec215042ef88900dba26958abfbac3d/src/core/cpu_core.jl#L6-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis.GPUCore"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis.GPUCore"><code>RecurrenceMicrostatesAnalysis.GPUCore</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GPUCore{B, M&lt;:MicrostateShape, S&lt;:SamplingMode} &lt;: RMACore</code></pre><p>Abstract GPU backend that implements the <strong>RecurrenceMicrostatesAnalysis.jl</strong> execution pipeline on graphics processing units.</p><p>The package provides a default implementation via <a href="#RecurrenceMicrostatesAnalysis.StandardGPUCore"><code>StandardGPUCore</code></a>.</p><p>Concrete subtypes of <code>GPUCore</code> must define the following fields:</p><ul><li><code>backend</code>: the GPU backend device (e.g. <code>CUDABackend</code>, <code>MetalBackend</code>).</li><li><code>shape</code>: the <a href="../tutorial/shapes_and_sampling/#RecurrenceMicrostatesAnalysis.MicrostateShape"><code>MicrostateShape</code></a> used to construct microstates.</li><li><code>sampling</code>: the <a href="../tutorial/shapes_and_sampling/#RecurrenceMicrostatesAnalysis.SamplingMode"><code>SamplingMode</code></a> used to sample the recurrence space.</li></ul><p><strong>Implementations</strong></p><ul><li><a href="#RecurrenceMicrostatesAnalysis.StandardGPUCore"><code>StandardGPUCore</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/81a1514ebec215042ef88900dba26958abfbac3d/src/core/gpu/gpu_core.jl#L6-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis.StandardCPUCore"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis.StandardCPUCore"><code>RecurrenceMicrostatesAnalysis.StandardCPUCore</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">StandardCPUCore{M&lt;:MicrostateShape, S&lt;:SamplingMode} &lt;: CPUCore{M, S}</code></pre><p>Default CPU backend implementation for <strong>RecurrenceMicrostatesAnalysis.jl</strong>.</p><p>This type provides the standard execution pipeline for computing recurrence microstate distributions on CPU devices.</p><p><strong>Initialization</strong></p><pre><code class="language-julia hljs">core = CPUCore(shape, sampling)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/81a1514ebec215042ef88900dba26958abfbac3d/src/core/cpu_core.jl#L23-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis.StandardGPUCore"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis.StandardGPUCore"><code>RecurrenceMicrostatesAnalysis.StandardGPUCore</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">StandardGPUCore{B, M&lt;:MicrostateShape, S&lt;:SamplingMode} &lt;: GPUCore{B, M, S}</code></pre><p>Default GPU backend implementation for <strong>RecurrenceMicrostatesAnalysis.jl</strong>.</p><p>This type provides the standard execution pipeline for computing recurrence microstate distributions on GPU devices.</p><p><strong>Initialization</strong></p><pre><code class="language-julia hljs">core = GPUCore(backend, shape, sampling)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/81a1514ebec215042ef88900dba26958abfbac3d/src/core/gpu/gpu_core.jl#L25-L37">source</a></section></details></article><div class="admonition is-info" id="Info-90e184d6d0d7f757"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-90e184d6d0d7f757" title="Permalink"></a></header><div class="admonition-body"><p>Backend implementations are located in <code>src/core/cpu_core.jl</code> and <code>src/core/gpu/gpu_core.jl</code>. If you plan to implement a new backend, we recommend opening an <a href="https://github.com/DynamicsUFPR/RecurrenceMicrostatesAnalysis.jl/issues">issue</a> on GitHub beforehand to discuss the design.</p></div></div><h3 id="Implementing-an-RMACore"><a class="docs-heading-anchor" href="#Implementing-an-RMACore">Implementing an RMACore</a><a id="Implementing-an-RMACore-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-an-RMACore" title="Permalink"></a></h3><p>Although it is possible to implement a custom <a href="#RecurrenceMicrostatesAnalysis.RMACore"><code>RMACore</code></a> directly, we <strong>do not recommend</strong> doing so. Instead, we strongly suggest implementing either a <a href="#RecurrenceMicrostatesAnalysis.CPUCore"><code>CPUCore</code></a> or a <a href="#RecurrenceMicrostatesAnalysis.GPUCore"><code>GPUCore</code></a>.</p><p>This approach allows you to reuse utility functions such as <code>get_offsets</code> and <code>get_power_vector</code>, which expect an <a href="#RecurrenceMicrostatesAnalysis.RMACore"><code>RMACore</code></a> as input. Since these functions have different implementations for <a href="#RecurrenceMicrostatesAnalysis.CPUCore"><code>CPUCore</code></a> and <a href="#RecurrenceMicrostatesAnalysis.GPUCore"><code>GPUCore</code></a>, writing a custom <code>RMACore</code> would require reimplementing them.</p><p>To avoid this, define a new struct that subtypes <a href="#RecurrenceMicrostatesAnalysis.CPUCore"><code>CPUCore</code></a> or <a href="#RecurrenceMicrostatesAnalysis.GPUCore"><code>GPUCore</code></a>. In this case, the only required method to implement is <a href="../tutorial/distributions/#RecurrenceMicrostatesAnalysis.histogram"><code>histogram</code></a>. For example:</p><pre><code class="language-julia hljs">using Random
using ComplexityMeasures
import RecurrenceMicrostatesAnalysis as rma
struct MyCore{M&lt;:rma.MicrostateShape, S&lt;:rma.SamplingMode} &lt;: rma.CPUCore{M, S}
    shape::M
    sampling::S
end</code></pre><pre><code class="language-julia hljs">function histogram(
    core::MyCore,
    x::rma.StateSpaceSet,
    y::rma.StateSpaceSet
)

    # Construct the sampling space and determine the number of samples
    space = rma.SamplingSpace(core.shape, x, y)
    samples = rma.get_num_samples(core.sampling, space)

    # Precompute power vector and offsets
    pv = rma.get_power_vector(core, core.shape)
    offsets = rma.get_offsets(core, core.shape)

    # Allocate histogram
    hist = zeros(Int, rma.get_histogram_size(core.shape))

    # Task-local RNG (ignored for Full sampling)
    local_rng = TaskLocalRNG()

    # Histogram computation
    for m in 1:samples
        #   Get the sample.
        i, j = rma.get_sample(core, core.sampling, space, local_rng, m)
        #   Compute the microstate index.
        idx = rma.compute_motif(core.shape.expr, x, y, i, j, pv, offsets)
        @inbounds hist[idx] += 1
    end

    return Counts(hist, eachindex(hist))
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">histogram (generic function with 1 method)</code></pre><div class="admonition is-info" id="Info-66df2817aee322ee"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-66df2817aee322ee" title="Permalink"></a></header><div class="admonition-body"><p>To ensure compatibility with the internal API, custom backends must support the keyword argument <code>threads</code> (for <a href="#RecurrenceMicrostatesAnalysis.CPUCore"><code>CPUCore</code></a>) or <code>groupsize</code> (for <a href="#RecurrenceMicrostatesAnalysis.GPUCore"><code>GPUCore</code></a>), as required by the <a href="../tutorial/distributions/#RecurrenceMicrostatesAnalysis.distribution"><code>distribution</code></a> overloads.</p></div></div><pre><code class="language-julia hljs">data = rma.StateSpaceSet(rand(1000))
histogram(MyCore(rma.Rect(rma.Standard(0.27), 2), rma.SRandom(0.05)), data, data)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr33"> Counts{Int64,1} over 16 outcomes</span>
  <span class="sgr90">1</span>  5756
  <span class="sgr90">2</span>  2249
  <span class="sgr90">3</span>  2228
  <span class="sgr90">4</span>  4331
  <span class="sgr90">5</span>  2340
  <span class="sgr90">6</span>  4375
  <span class="sgr90">7</span>  3906
  <span class="sgr90">8</span>  1306
  <span class="sgr90">9</span>  2382
 <span class="sgr90">10</span>  4035
 <span class="sgr90">11</span>  4197
 <span class="sgr90">12</span>  1402
 <span class="sgr90">13</span>  4350
 <span class="sgr90">14</span>  1416
 <span class="sgr90">15</span>  1487
 <span class="sgr90">16</span>  4141</code></pre><div class="admonition is-warning" id="Warning-e8f28073d55a4d33"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-e8f28073d55a4d33" title="Permalink"></a></header><div class="admonition-body"><p>CPU and GPU backends differ significantly in their execution models. In the GPU backend, random samples must be generated before histogram computation. The histogram itself is computed inside the <code>gpu_histogram!</code> kernel.</p><p>See the <a href="#RecurrenceMicrostatesAnalysis.StandardGPUCore"><code>StandardGPUCore</code></a> implementation in <code>src/core/gpu_core.jl</code> for details.</p></div></div><div class="admonition is-danger" id="Danger-b27f396dfcfcb9c1"><header class="admonition-header">Danger<a class="admonition-anchor" href="#Danger-b27f396dfcfcb9c1" title="Permalink"></a></header><div class="admonition-body"><p><strong>RecurrenceMicrostatesAnalysis.jl</strong> provides multiple backends that are only partially compatible.</p><ul><li>CPU backends do not necessarily support spatial data.</li><li>Spatial analyses require dedicated implementations.</li><li>The GPU backend is fully incompatible with spatial data.</li></ul><p>Please consider these limitations carefully when extending or using backend functionality.</p></div></div><h2 id="Adding-a-New-Recurrence-Function"><a class="docs-heading-anchor" href="#Adding-a-New-Recurrence-Function">Adding a New Recurrence Function</a><a id="Adding-a-New-Recurrence-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-a-New-Recurrence-Function" title="Permalink"></a></h2><h3 id="Steps"><a class="docs-heading-anchor" href="#Steps">Steps</a><a id="Steps-1"></a><a class="docs-heading-anchor-permalink" href="#Steps" title="Permalink"></a></h3><ol><li>Define the mathematical expression of your recurrence function. It must return a binary value: <code>0</code> for non-recurrence and <code>1</code> for recurrence.</li><li>Define a new type <code>YourType &lt;:</code><a href="../tutorial/recurrences/#RecurrenceMicrostatesAnalysis.RecurrenceExpression"><code>RecurrenceExpression</code></a>. Constant parameters (e.g., thresholds and metric) should be fields of this type.</li><li>Implement the appropriate <a href="../tutorial/recurrences/#RecurrenceMicrostatesAnalysis.recurrence"><code>recurrence</code></a> dispatch:<ul><li>Time series:   <code>recurrence(expr::YourType, x::StateSpaceSet, y::StateSpaceSet, i::Int, j::Int)</code></li><li>Spatial data:   <code>recurrence(expr::YourType, x::AbstractArray{&lt;:Real}, y::AbstractArray{&lt;:Real}, i::NTuple{N,Int}, j::NTuple{M,Int})</code></li></ul></li><li>Add a docstring describing the mathematical definition and relevant references.</li><li>Add the recurrence expression to <code>docs/src/tutorial/recurrences.md</code>.</li><li>Add the expression to the <a href="../tutorial/recurrences/#RecurrenceMicrostatesAnalysis.RecurrenceExpression"><code>RecurrenceExpression</code></a> docstring.</li><li>Add tests to <code>test/distributions.jl</code> under the test set <code>recurrence expressions (with CPUCore)</code>.</li></ol><div class="admonition is-warning" id="Warning-ff1d697903628abe"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-ff1d697903628abe" title="Permalink"></a></header><div class="admonition-body"><p>A recurrence function must always return <code>UInt(0)</code> or <code>UInt(1)</code>.</p></div></div><div class="admonition is-todo" id="Todo-42185fc816396cf6"><header class="admonition-header">Todo<a class="admonition-anchor" href="#Todo-42185fc816396cf6" title="Permalink"></a></header><div class="admonition-body"><p>To support GPU execution, also implement <code>gpu_recurrence(expr::YourType, x, y, i, j, n)</code>. See <a href="../tutorial/recurrences/#RecurrenceMicrostatesAnalysis.Standard"><code>Standard</code></a> for reference.</p></div></div><h2 id="Adding-a-New-Sampling-Mode"><a class="docs-heading-anchor" href="#Adding-a-New-Sampling-Mode">Adding a New Sampling Mode</a><a id="Adding-a-New-Sampling-Mode-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-a-New-Sampling-Mode" title="Permalink"></a></h2><h3 id="Steps-2"><a class="docs-heading-anchor" href="#Steps-2">Steps</a><a class="docs-heading-anchor-permalink" href="#Steps-2" title="Permalink"></a></h3><ol><li>Define how the sampling mode operates: which microstates are sampled, from which regions, and in what quantity. The <a href="../tutorial/shapes_and_sampling/#RecurrenceMicrostatesAnalysis.SamplingSpace"><code>SamplingSpace</code></a> must be taken into account when designing the sampling logic.</li><li>Define a new struct that is a subtype of <a href="../tutorial/shapes_and_sampling/#RecurrenceMicrostatesAnalysis.SamplingMode"><code>SamplingMode</code></a>. The struct may be empty (e.g. <a href="../tutorial/shapes_and_sampling/#RecurrenceMicrostatesAnalysis.Full"><code>Full</code></a>) or contain parameters such as a sampling rate (e.g. <a href="../tutorial/shapes_and_sampling/#RecurrenceMicrostatesAnalysis.SRandom"><code>SRandom</code></a>).</li><li>Implement the dispatch <code>get_num_samples(mode::YourType, space::SamplingSpace)</code> which determines the number of samples to be drawn given the sampling mode and the sampling space. Two sampling space types exist: <code>SSRect2</code> (time series) and <code>SSRectN</code> (spatial data).</li><li>Implement the dispatch <code>get_sample(core::RMACore, mode::YourType, space::SamplingSpace)</code> which returns the positions to be sampled. Separate implementations may be required for each <a href="#RecurrenceMicrostatesAnalysis.RMACore"><code>RMACore</code></a> and each <a href="../tutorial/shapes_and_sampling/#RecurrenceMicrostatesAnalysis.SamplingSpace"><code>SamplingSpace</code></a>. Full coverage is encouraged but not mandatory, provided that the supported cases are clearly documented in the docstring.</li><li>Add a docstring to your sampling mode describing its behavior and initialization. Follow the style of the existing sampling modes listed in <a href="../tutorial/shapes_and_sampling/#Implemented-sampling-modes">Implemented sampling modes</a>.</li><li>Add your sampling mode to the list in <code>docs/src/tutorial/shapes_and_sampling.md</code>.</li><li>Add your type to the list in the <a href="../tutorial/shapes_and_sampling/#RecurrenceMicrostatesAnalysis.SamplingMode"><code>SamplingMode</code></a> docstring.</li><li>Add tests in <code>test/distributions.jl</code> under the test set <code>sampling mode (CPU backend)</code>.</li></ol><div class="admonition is-warning" id="Warning-db785e04485fa4c6"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-db785e04485fa4c6" title="Permalink"></a></header><div class="admonition-body"><p>The <code>get_sample</code> logic differs between CPU and GPU backends. On the CPU, random samples are generated during histogram computation. On the GPU, samples must be generated beforehand, outside the kernel, and the kernel operates only on precomputed values.</p></div></div><h2 id="Adding-a-new-Microstate-Shape"><a class="docs-heading-anchor" href="#Adding-a-new-Microstate-Shape">Adding a new Microstate Shape</a><a id="Adding-a-new-Microstate-Shape-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-a-new-Microstate-Shape" title="Permalink"></a></h2><p>Defining a Microstate Shape is one of the most challenging tasks in this package (except for backend development, which is described by an <a href="#RecurrenceMicrostatesAnalysis.RMACore"><code>RMACore</code></a>).</p><p>A microstate shape acts as an intermediate structure between the sampling process and the recurrence function. Given an initial RP position <span>$(i, j)$</span>, it determines which additional recurrences must be evaluated and computes them using the recurrence expression. The resulting microstate is then converted into a decimal representation, which is used as an index in the histogram.</p><h3 id="Design-considerations"><a class="docs-heading-anchor" href="#Design-considerations">Design considerations</a><a id="Design-considerations-1"></a><a class="docs-heading-anchor-permalink" href="#Design-considerations" title="Permalink"></a></h3><p>Before implementing a microstate shape, it is essential to define its structure and reading order. For example, square microstates are typically read row-wise, while triangular microstates may be read column-wise. Each position in the microstate structure must be associated with a power of two in order to convert the binary microstate into a decimal index.</p><p class="math-container">\[\begin{pmatrix}
2^0 &amp; 2^1 &amp; 2^2 \\
2^3 &amp; 2^4 &amp; 2^5 \\
2^6 &amp; 2^7 &amp; 2^8
\end{pmatrix}\]</p><h3 id="Implementation-steps"><a class="docs-heading-anchor" href="#Implementation-steps">Implementation steps</a><a id="Implementation-steps-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-steps" title="Permalink"></a></h3><p>Define a new struct that is a subtype of <a href="../tutorial/shapes_and_sampling/#RecurrenceMicrostatesAnalysis.MicrostateShape"><code>MicrostateShape</code></a>. The struct must include a field <code>expr</code>, which stores the <a href="../tutorial/recurrences/#RecurrenceMicrostatesAnalysis.RecurrenceExpression"><code>RecurrenceExpression</code></a> used to compute recurrences at runtime.</p><p>Unlike <a href="../tutorial/recurrences/#RecurrenceMicrostatesAnalysis.RecurrenceExpression"><code>RecurrenceExpression</code></a> and <a href="../tutorial/shapes_and_sampling/#RecurrenceMicrostatesAnalysis.SamplingMode"><code>SamplingMode</code></a>, a <a href="../tutorial/shapes_and_sampling/#RecurrenceMicrostatesAnalysis.MicrostateShape"><code>MicrostateShape</code></a> does not require the implementation of <code>recurrence</code> or <code>get_sample</code> methods. Microstate computation is handled by the unified <code>compute_motif</code> function for the <a href="#RecurrenceMicrostatesAnalysis.CPUCore"><code>CPUCore</code></a>, and by <code>gpu_compute_motif</code> for the <a href="#RecurrenceMicrostatesAnalysis.GPUCore"><code>GPUCore</code></a>.</p><p>The only exception is spatial data, for which a custom <code>compute_motif</code> implementation is required. For example:</p><pre><code class="language-julia hljs">@inline function compute_motif(
    shape::RectN,
    x::AbstractArray{&lt;: Real},
    y::AbstractArray{&lt;: Real},
    idx::Vector{Int},
    itr::Vector{Int},
    power_vector::SVector{N, Int}
) where {N}
    
    index = 0
    dim = ndims(x) - 1
    copy!(itr, idx)

    @inbounds @fastmath for p in power_vector

        i = ntuple(k -&gt; itr[k], dim)
        j = ntuple(k -&gt; itr[dim + k], length(shape.structure) - dim)

        index += recurrence(shape.expr, x, y, i, j) * p

        itr[1] += 1
        for k in 1:length(shape.structure) - 1
            if (itr[k] &gt; idx[k] + (shape.structure[k] - 1))
                itr[k] = idx[k]
                itr[k + 1] += 1
            else
                break
            end
        end
    end

    return index + 1
end</code></pre><p>Although time-series microstate shapes do not require a custom <code>compute_motif</code> implementation, three utility functions must be defined to describe the properties of the shape:</p><ol><li><p><code>get_histogram_size(shape::YourType)</code>   Returns the length of the histogram, given by <span>$2^\sigma$</span>, where <span>$\sigma$</span> is the number of recurrences in the microstate structure.</p></li><li><p><code>get_power_vector(core::RMACore, shape::YourType)</code>   Returns the vector of powers of two used to convert the microstate into its decimal representation. This function differs between CPU and GPU backends due to integer size (<code>Int</code> on CPU, <code>Int32</code> on GPU).</p></li><li><p><code>get_offsets(core::RMACore, shape::YourType)</code>   Returns the offsets relative to the initial position <span>$(i, j)$</span> that define the remaining recurrence positions of the microstate. This function must be consistent with <code>get_power_vector</code> and also differs between CPU and GPU backends.</p></li></ol><div class="admonition is-success" id="Tip-39fa0b597d5ddf44"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-39fa0b597d5ddf44" title="Permalink"></a></header><div class="admonition-body"><p>For improved performance, we strongly recommend using <code>@generated</code> functions when implementing these utilities (except for spatial data).</p></div></div><p>Additionally, a <a href="../tutorial/shapes_and_sampling/#RecurrenceMicrostatesAnalysis.SamplingSpace"><code>SamplingSpace</code></a> must be defined for the new microstate shape. For time-series data, this is typically <code>SSRect2</code>, while spatial data require <code>SSRectN</code>.</p><p>The sampling space must be initialized using the following constructor:</p><pre><code class="language-julia hljs">SamplingSpace(
    ::MicrostateShape, 
    x::Union{StateSpaceSet, AbstractGPUVector{SVector{N, Float32}}}, 
    y::Union{StateSpaceSet, AbstractGPUVector{SVector{N, Float32}}}
)</code></pre><p>After implementation, the following steps are required:</p><ol><li>Add a docstring to your <a href="../tutorial/shapes_and_sampling/#RecurrenceMicrostatesAnalysis.MicrostateShape"><code>MicrostateShape</code></a>, explaining its behavior and initialization.</li><li>Add the definition to the section <a href="../tutorial/shapes_and_sampling/#Implemented-microstates-shapes">Implemented microstates shapes</a> in <code>docs/src/tutorial/shapes_and_sampling.md</code>.</li><li>Add the type to the list in the <a href="../tutorial/shapes_and_sampling/#RecurrenceMicrostatesAnalysis.MicrostateShape"><code>MicrostateShape</code></a> docstring.</li><li>Add tests to <code>test/distributions.jl</code> under the test set <code>motif shapes (with CPUCore)</code>.</li></ol><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>First, we define the shape struct.</p><pre><code class="language-julia hljs">using RecurrenceMicrostatesAnalysis
struct Line{N, B, E &lt;: RecurrenceExpression} &lt;: MicrostateShape
    expr::E
end

Line(expr::E, N; B = 2) where {E} = Line{N, B, E}(expr)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.Line</code></pre><p>Next, we implements the three utils functions.</p><pre><code class="language-julia hljs">@generated function get_histogram_size(::Line{N, B, E}) where {N, B, E}
    size = B^(N)
    return :( $size )
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">get_histogram_size (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">@generated function get_power_vector(::CPUCore, ::Line{N, B, E}) where {N, B, E}
    expr = :(SVector{$N}( $([:(B^$i) for i in 0:(N-1)]... ) ))
    return expr
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">get_power_vector (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">@generated function get_offsets(::CPUCore, ::Line{N, B, E}) where {N, B, E}
    elems = [ :(SVector{2, Int}(0, $h)) for h in 0:(N - 1)]
    return :( SVector{$N, $(SVector{2, Int})}( $(elems...) ) )
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">get_offsets (generic function with 1 method)</code></pre><p>Finally, we define our sampling space: (can be only for time series)</p><pre><code class="language-julia hljs">using GPUArraysCore, StaticArrays
SamplingSpace(
    ::Line{N, B, E},
    x::Union{StateSpaceSet, AbstractGPUVector{SVector{D, Float32}}},
    y::Union{StateSpaceSet, AbstractGPUVector{SVector{D, Float32}}}
) where {N, B, E&lt;:RecurrenceExpression, D} = RecurrenceMicrostatesAnalysis.SSRect2(length(x), length(y) - N + 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SamplingSpace</code></pre><p>And done, the shape can be used üòÉ. Remember to document it!</p><div class="admonition is-warning" id="Warning-5c476ac4adc27eeb"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-5c476ac4adc27eeb" title="Permalink"></a></header><div class="admonition-body"><p>The backend needs to have access to the util functions, them it is important to do the implementation inside the package module.</p></div></div><h2 id="Adding-a-New-Quantifier"><a class="docs-heading-anchor" href="#Adding-a-New-Quantifier">Adding a New Quantifier</a><a id="Adding-a-New-Quantifier-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-a-New-Quantifier" title="Permalink"></a></h2><h3 id="Steps-3"><a class="docs-heading-anchor" href="#Steps-3">Steps</a><a class="docs-heading-anchor-permalink" href="#Steps-3" title="Permalink"></a></h3><ol><li>Define a new quantifier type that is a subtype of <a href="../tutorial/quantifiers/#RecurrenceMicrostatesAnalysis.QuantificationMeasure"><code>QuantificationMeasure</code></a>.</li><li>Implement the corresponding <a href="../tutorial/quantifiers/#RecurrenceMicrostatesAnalysis.measure"><code>measure</code></a> dispatch used to compute the quantifier.</li><li>Add a docstring to the quantifier type, following the style of existing quantifiers.</li><li>Document the quantifier in <code>docs/src/tutorial/quantifiers.md</code>, including its definition, mathematical formulation, references, and examples when possible.</li><li>Add the quantifier to the list in the <a href="../tutorial/quantifiers/#RecurrenceMicrostatesAnalysis.QuantificationMeasure"><code>QuantificationMeasure</code></a> docstring.</li><li>Add tests for the quantifier in <code>test/rqa.jl</code>.</li></ol><h2 id="Adding-a-New-GPU-Metric"><a class="docs-heading-anchor" href="#Adding-a-New-GPU-Metric">Adding a New GPU Metric</a><a id="Adding-a-New-GPU-Metric-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-a-New-GPU-Metric" title="Permalink"></a></h2><p>Since the <a href="https://github.com/JuliaStats/Distances.jl">Distances.jl</a> package is not compatible with GPU execution, metric evaluations must be implemented manually to enable GPU support.</p><h3 id="Steps-4"><a class="docs-heading-anchor" href="#Steps-4">Steps</a><a class="docs-heading-anchor-permalink" href="#Steps-4" title="Permalink"></a></h3><ol><li>Define a new type that is a subtype of <a href="../tutorial/gpu/#RecurrenceMicrostatesAnalysis.GPUMetric"><code>GPUMetric</code></a>.</li><li>Implement the dispatch   <code>gpu_evaluate(::YourMetric, x, y, i, j, n)</code>   where <code>x</code> and <code>y</code> are <code>AbstractGPUVector{SVector{N, Float32}}</code>, <code>i</code> and <code>j</code> are indices, and <code>n</code> is the dimensionality of the vectors.</li><li>Add a docstring describing the metric, including its mathematical definition and parameters. Include references when applicable.</li><li>Document the metric in the section <a href="../tutorial/gpu/#Implemented-GPU-metrics">Implemented GPU metrics</a> in <code>docs/src/tutorial/gpu.md</code>.</li><li>Add a reference to the metric in the <a href="../tutorial/gpu/#RecurrenceMicrostatesAnalysis.GPUMetric"><code>GPUMetric</code></a> docstring.</li></ol><div class="admonition is-danger" id="Danger-514d88df6b001d5"><header class="admonition-header">Danger<a class="admonition-anchor" href="#Danger-514d88df6b001d5" title="Permalink"></a></header><div class="admonition-body"><p>GPU backends in <strong>RecurrenceMicrostatesAnalysis.jl</strong> operate exclusively with <code>Float32</code>. The use of <code>Float64</code> is not supported.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/ml/">¬´ Machine Learning</a><a class="docs-footer-nextpage" href="../refs/">References ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 13 January 2026 21:25">Tuesday 13 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
