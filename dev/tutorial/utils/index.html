<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Utils · RecurrenceMicrostatesAnalysis.jl</title><meta name="title" content="Utils · RecurrenceMicrostatesAnalysis.jl"/><meta property="og:title" content="Utils · RecurrenceMicrostatesAnalysis.jl"/><meta property="twitter:title" content="Utils · RecurrenceMicrostatesAnalysis.jl"/><meta name="description" content="Documentation for RecurrenceMicrostatesAnalysis.jl."/><meta property="og:description" content="Documentation for RecurrenceMicrostatesAnalysis.jl."/><meta property="twitter:description" content="Documentation for RecurrenceMicrostatesAnalysis.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">RecurrenceMicrostatesAnalysis.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../distributions/">Distributions</a></li><li><a class="tocitem" href="../quantifiers/">Quantifiers</a></li><li><a class="tocitem" href="../recurrences/">Recurrence Functions</a></li><li><a class="tocitem" href="../shapes_and_sampling/">Shapes and Sampling</a></li><li><a class="tocitem" href="../gpu/">GPU</a></li><li class="is-active"><a class="tocitem" href>Utils</a><ul class="internal"><li><a class="tocitem" href="#Optimizing-a-parameter"><span>Optimizing a parameter</span></a></li><li><a class="tocitem" href="#Operations-on-microstates"><span>Operations on microstates</span></a></li></ul></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/ml/">Machine Learning</a></li></ul></li><li><a class="tocitem" href="../../dev/">Developers</a></li><li><a class="tocitem" href="../../refs/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li class="is-active"><a href>Utils</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Utils</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/main/docs/src/tutorial/utils.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Utils"><a class="docs-heading-anchor" href="#Utils">Utils</a><a id="Utils-1"></a><a class="docs-heading-anchor-permalink" href="#Utils" title="Permalink"></a></h1><p>This section describes utility functionalities provided by <strong>RecurrenceMicrostatesAnalysis.jl</strong>, including parameter optimization and operations on recurrence microstates.</p><h2 id="Optimizing-a-parameter"><a class="docs-heading-anchor" href="#Optimizing-a-parameter">Optimizing a parameter</a><a id="Optimizing-a-parameter-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizing-a-parameter" title="Permalink"></a></h2><p>When working with recurrence plots (RPs), a well-known challenge is selecting an appropriate recurrence threshold. Within the RMA framework, this issue is addressed by optimizing an information-theoretic or complexity-based measure with respect to the threshold parameter.</p><p>In practice, it is common to determine the threshold that maximizes either the <a href="../quantifiers/#RecurrenceMicrostatesAnalysis.RecurrenceEntropy"><code>RecurrenceEntropy</code></a> or the <a href="../quantifiers/#Disorder"><code>Disorder</code></a> quantifier (<a href="../../refs/#Prado2023Sampling">Lima Prado <em>et al.</em>, 2023</a>).</p><p>This optimization procedure is implemented via the <a href="#RecurrenceMicrostatesAnalysis.optimize"><code>optimize</code></a> function, which computes the optimal value of a given <a href="#RecurrenceMicrostatesAnalysis.Parameter"><code>Parameter</code></a>.</p><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis.Parameter"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis.Parameter"><code>RecurrenceMicrostatesAnalysis.Parameter</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Parameter</code></pre><p>Abstract supertype for free parameters that can be optimized using RMA.</p><p><strong>Implementations</strong></p><ul><li><a href="#RecurrenceMicrostatesAnalysis.Threshold"><code>Threshold</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/ef56ed683e529e7a8bb8bf0472a4899ba712af62/src/core/optimize.jl#L6-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis.optimize"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis.optimize"><code>RecurrenceMicrostatesAnalysis.optimize</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">optimize(param::Parameter, qm::QuantificationMeasure, args...)</code></pre><p>Optimize a free <a href="#RecurrenceMicrostatesAnalysis.Parameter"><code>Parameter</code></a> using the specified <a href="../quantifiers/#RecurrenceMicrostatesAnalysis.QuantificationMeasure"><code>QuantificationMeasure</code></a>.</p><div class="admonition is-warning" id="Warning-f3dbd4303c056ac4"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-f3dbd4303c056ac4" title="Permalink"></a></header><div class="admonition-body"><p>The <code>optimize</code> function may compute multiple distributions and can be computationally expensive. Avoid calling it inside performance-critical loops.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/ef56ed683e529e7a8bb8bf0472a4899ba712af62/src/core/optimize.jl#L19-L27">source</a></section></details></article><h3 id="Parameters"><a class="docs-heading-anchor" href="#Parameters">Parameters</a><a id="Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Parameters" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis.Threshold"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis.Threshold"><code>RecurrenceMicrostatesAnalysis.Threshold</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Threshold &lt;: Parameter</code></pre><p>Threshold parameter used to classify two states as recurrent or non-recurrent.</p><p>The <code>Threshold</code> parameter can be optimized using the <a href="#RecurrenceMicrostatesAnalysis.optimize"><code>optimize</code></a> function in combination with specific <a href="../quantifiers/#RecurrenceMicrostatesAnalysis.QuantificationMeasure"><code>QuantificationMeasure</code></a>s:</p><pre><code class="language-julia hljs">optimize(Threshold(), RecurrenceEntropy(), [x], n::int; kwargs...)
optimize(Threshold(), qm::Disorder{N}, [x]; kwargs...)</code></pre><div class="admonition is-compat" id="Compat-94240e527dcf57b2"><header class="admonition-header">Compat<a class="admonition-anchor" href="#Compat-94240e527dcf57b2" title="Permalink"></a></header><div class="admonition-body"><p>Threshold optimization using RMA is currently supported only for the <a href="../quantifiers/#RecurrenceMicrostatesAnalysis.RecurrenceEntropy"><code>RecurrenceEntropy</code></a> and <a href="../quantifiers/#Disorder"><code>Disorder</code></a> quantification measures.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>qm</code>: A <a href="../quantifiers/#RecurrenceMicrostatesAnalysis.QuantificationMeasure"><code>QuantificationMeasure</code></a> used to determine the optimal threshold. Supported measures are <a href="../quantifiers/#RecurrenceMicrostatesAnalysis.RecurrenceEntropy"><code>RecurrenceEntropy</code></a> and <a href="../quantifiers/#Disorder"><code>Disorder</code></a>.</li><li><code>[x]</code>: Input data used to estimate the optimal threshold.</li><li><code>n</code>: Size of the square microstate used in the optimization.</li></ul><p><strong>Returns</strong></p><p>A <code>Tuple{Float64, Float64}</code>, where:</p><ul><li>the first element is the optimal threshold value, and</li><li>the second element is the value of the corresponding <a href="../quantifiers/#RecurrenceMicrostatesAnalysis.QuantificationMeasure"><code>QuantificationMeasure</code></a> at the optimum.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>rate</code>: Sampling rate. Default is <code>0.05</code>.</li><li><code>sampling</code>: Sampling mode. Default is <a href="../shapes_and_sampling/#RecurrenceMicrostatesAnalysis.SRandom"><code>SRandom</code></a>.</li><li><code>th_max_range</code>: Fraction of the maximum distance defining the upper bound of the threshold search range. Default is <code>0.5</code>.</li><li><code>th_start</code>: Initial value of the threshold search range. Default is <code>1e-6</code>.</li><li><code>fraction</code>: Interaction fraction controlling the refinement process. Default is <code>5</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Distributions, RecurrenceMicrostatesAnalysis
data = StateSpaceSet(rand(Uniform(0, 1), 1000))
th, s = optimize(Threshold(), RecurrenceEntropy(), data, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/ef56ed683e529e7a8bb8bf0472a4899ba712af62/src/utils/opt/threshold.jl#L6-L45">source</a></section></details></article><h2 id="Operations-on-microstates"><a class="docs-heading-anchor" href="#Operations-on-microstates">Operations on microstates</a><a id="Operations-on-microstates-1"></a><a class="docs-heading-anchor-permalink" href="#Operations-on-microstates" title="Permalink"></a></h2><p>The package also provides a set of operations that can be applied to recurrence microstates or to their decimal representations.</p><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis.Operation"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis.Operation"><code>RecurrenceMicrostatesAnalysis.Operation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Operation</code></pre><p>Abstract supertype for operations that can be applied to recurrence microstates or to recurrence microstate distributions.</p><p><strong>Implementations:</strong></p><ul><li><a href="#RecurrenceMicrostatesAnalysis.PermuteColumns"><code>PermuteColumns</code></a></li><li><a href="#RecurrenceMicrostatesAnalysis.PermuteRows"><code>PermuteRows</code></a></li><li><a href="#RecurrenceMicrostatesAnalysis.Transpose"><code>Transpose</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/ef56ed683e529e7a8bb8bf0472a4899ba712af62/src/core/operation.jl#L6-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis.operate"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis.operate"><code>RecurrenceMicrostatesAnalysis.operate</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">operate(op::Operation, [...])</code></pre><p>Apply the operation defined by the given <a href="#RecurrenceMicrostatesAnalysis.Operation"><code>Operation</code></a> instance.</p><p>The accepted arguments (<code>[...]</code>) depend on the specific operation implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/ef56ed683e529e7a8bb8bf0472a4899ba712af62/src/core/operation.jl#L22-L28">source</a></section></details></article><h3 id="Permutations-and-Transposition"><a class="docs-heading-anchor" href="#Permutations-and-Transposition">Permutations and Transposition</a><a id="Permutations-and-Transposition-1"></a><a class="docs-heading-anchor-permalink" href="#Permutations-and-Transposition" title="Permalink"></a></h3><p>When working with square microstates, it is natural to consider symmetry operations such as row and column permutations, as well as transposition. These operations are particularly important for defining equivalence classes used in the computation of the <a href="../quantifiers/#Disorder"><code>Disorder</code></a> quantifier.</p><p>To illustrate these operations, we consider a square microstate of size <span>$3 \times 3$</span>:</p><p class="math-container">\[\mathbf{M} = \begin{pmatrix}
a &amp; b &amp; c \\
d &amp; e &amp; f \\
g &amp; h &amp; i
\end{pmatrix}.\]</p><div class="admonition is-info" id="Info-bfd27e01e41b041a"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-bfd27e01e41b041a" title="Permalink"></a></header><div class="admonition-body"><p>The primary purpose of these operations is to define equivalence classes of microstates used in the computation of <a href="../quantifiers/#Disorder"><code>Disorder</code></a>.</p></div></div><h4 id="Permutations-of-Rows"><a class="docs-heading-anchor" href="#Permutations-of-Rows">Permutations of Rows</a><a id="Permutations-of-Rows-1"></a><a class="docs-heading-anchor-permalink" href="#Permutations-of-Rows" title="Permalink"></a></h4><p>Let <span>$\sigma \in S_N$</span> be a permutation, and let <span>$\mathcal{L}_\sigma$</span> denote the operator that permutes the rows of a microstate <span>$\mathbf{M}$</span> according to <span>$\sigma$</span>.</p><p>For example, for <span>$\sigma = 132$</span>, the third and second rows are exchanged, while the first row remains unchanged:</p><p class="math-container">\[\mathcal{L}_{132}\mathbf{M} = \begin{pmatrix}
a &amp; b &amp; c \\
g &amp; h &amp; i \\
d &amp; e &amp; f
\end{pmatrix}.\]</p><p>For a given microstate size <span>$n$</span>, all possible row (or column) permutations can be generated using the <a href="https://juliamath.github.io/Combinatorics.jl/stable/">Combinatorics.jl</a> package:</p><pre><code class="language-julia hljs">using Combinatorics

n = 3
Sn = collect(permutations(1:n))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6-element Vector{Vector{Int64}}:
 [1, 2, 3]
 [1, 3, 2]
 [2, 1, 3]
 [2, 3, 1]
 [3, 1, 2]
 [3, 2, 1]</code></pre><pre><code class="language-julia hljs">σ = Sn[2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Int64}:
 1
 3
 2</code></pre><p>The permutation is applied using <a href="#RecurrenceMicrostatesAnalysis.PermuteRows"><code>PermuteRows</code></a>  operation. For example, consider the microstate with decimal index <span>$I = 237$</span>:</p><p class="math-container">\[\mathbf{M} = \begin{pmatrix}
0 &amp; 0 &amp; 1 \\
1 &amp; 0 &amp; 1 \\
1 &amp; 1 &amp; 0
\end{pmatrix}.\]</p><pre><code class="language-julia hljs">using RecurrenceMicrostatesAnalysis

shape = Rect(n, n)
row_permutation = PermuteRows(shape)

operate(row_permutation, 237, σ)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">349</code></pre><p>The result is the microstate with decimal identifier <span>$I = 239$</span>, corresponding to:</p><p class="math-container">\[\mathcal{L}_{132}\mathbf{M} = \begin{pmatrix}
0 &amp; 0 &amp; 1 \\
1 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 1
\end{pmatrix}.\]</p><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis.PermuteRows"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis.PermuteRows"><code>RecurrenceMicrostatesAnalysis.PermuteRows</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PermuteRows{R, C} &lt;: Operation</code></pre><p>Operation that permutes the rows of a microstate <span>$\mathbf{M}$</span>.</p><p>To initialize a <code>PermuteRows</code> operation, a rectangular microstate shape must be provided via a <a href="../shapes_and_sampling/#RecurrenceMicrostatesAnalysis.Rect"><code>Rect</code></a> structure:</p><pre><code class="language-julia hljs">PermuteRows(::Rect2{R, C, B, E})</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">PermuteRows(Rect(3, 3))     #   Microstate 3 x 3
PermuteRows(Rest(3, 1))     #   Microstate 3 x 1 (it is a column)</code></pre><p>This operation is applied via the <a href="#RecurrenceMicrostatesAnalysis.operate"><code>operate</code></a> function:</p><pre><code class="language-julia hljs">operate(::PermuteRows, I::Int, σ::Vector{Int})</code></pre><p><strong>Arguments</strong></p><ul><li><code>op</code>: A <code>PermuteRows</code> operation.</li><li><code>I</code>: Decimal identifier of the microstate (1-based).</li><li><code>σ</code>: Permutation of rows to be applied.</li></ul><p><strong>Returns</strong></p><p>The resulting microstate binary identifier (1-based).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/ef56ed683e529e7a8bb8bf0472a4899ba712af62/src/utils/operations/permute_rows.jl#L6-L35">source</a></section></details></article><h4 id="Permutations-of-Columns"><a class="docs-heading-anchor" href="#Permutations-of-Columns">Permutations of Columns</a><a id="Permutations-of-Columns-1"></a><a class="docs-heading-anchor-permalink" href="#Permutations-of-Columns" title="Permalink"></a></h4><p>Column permutations follow the same logic as row permutations, but are applied to the columns of the microstate.</p><p>Let <span>$\mathcal{C}_\sigma$</span> denote the operator that permutes the columns of <span>$\mathbf{M}$</span> according to <span>$\sigma \in S_N$</span>. For <span>$\sigma = 132$</span>, the transformation is given by:</p><p class="math-container">\[\mathcal{C}_{132}\mathbf{M} = \begin{pmatrix}
a &amp; c &amp; b \\
d &amp; f &amp; e \\
g &amp; i &amp; h
\end{pmatrix}.\]</p><p>Using the same example of <span>$I = 237$</span>, column permutation is performed using the <a href="#RecurrenceMicrostatesAnalysis.PermuteColumns"><code>PermuteColumns</code></a> operation:</p><pre><code class="language-julia hljs">col_permutation = PermuteColumns(shape; S = Sn)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PermuteColumns{3, 3}(Vector{UInt32}[[0x00000000, 0x00000001, 0x00000002, 0x00000003, 0x00000004, 0x00000005, 0x00000006, 0x00000007], [0x00000000, 0x00000001, 0x00000004, 0x00000005, 0x00000002, 0x00000003, 0x00000006, 0x00000007], [0x00000000, 0x00000002, 0x00000001, 0x00000003, 0x00000004, 0x00000006, 0x00000005, 0x00000007], [0x00000000, 0x00000002, 0x00000004, 0x00000006, 0x00000001, 0x00000003, 0x00000005, 0x00000007], [0x00000000, 0x00000004, 0x00000001, 0x00000005, 0x00000002, 0x00000006, 0x00000003, 0x00000007], [0x00000000, 0x00000004, 0x00000002, 0x00000006, 0x00000001, 0x00000005, 0x00000003, 0x00000007]])</code></pre><pre><code class="language-julia hljs">operate(col_permutation, 237, 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">347</code></pre><p>The resulting microstate has decimal identifier <span>$I = 347$</span>, corresponding to:</p><p class="math-container">\[\mathcal{C}_{132}\mathbf{M} = \begin{pmatrix}
0 &amp; 1 &amp; 0 \\
1 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 1
\end{pmatrix}.\]</p><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis.PermuteColumns"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis.PermuteColumns"><code>RecurrenceMicrostatesAnalysis.PermuteColumns</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PermuteColumns{R, C} &lt;: Operation</code></pre><p>Operation that permutes the columns of a microstate <span>$\mathbf{M}$</span>.</p><p>To initialize a <code>PermuteColumns</code> operation, a rectangular microstate shape must be provided via a <a href="../shapes_and_sampling/#RecurrenceMicrostatesAnalysis.Rect"><code>Rect</code></a> structure:</p><pre><code class="language-julia hljs">PermuteColumns(::Rect2{R, C, B, E}; S::Vector{Vector{Int}} = collect(permutations(1:C))</code></pre><p>Here, the keyword argument <code>S</code> defines the set <span>$S_n$</span> of column permutations. The <code>PermuteColumns</code> struct precomputes the column permutations for each row of the microstate. These precomputed permutations can be accessed via the field <code>Q</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">PermuteColumns(Rect(3, 3))     #   Microstate 3 x 3
PermuteColumns(Rest(1, 3))     #   Microstate 1 x 3 (it is a line)</code></pre><p>This operation is applied via the <a href="#RecurrenceMicrostatesAnalysis.operate"><code>operate</code></a> function:</p><pre><code class="language-julia hljs">operate(op::PermuteColumns, I::Int, Qi::Int)</code></pre><p><strong>Arguments</strong></p><ul><li><code>op</code>: A <code>PermuteColumns</code> operation.</li><li><code>I</code>: Decimal identifier of the microstate (1-based).</li><li><code>Qi</code>: Index of the permutation in the set <code>S</code>.</li></ul><p><strong>Returns</strong></p><p>The resulting microstate decimal identifier (1-based).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/ef56ed683e529e7a8bb8bf0472a4899ba712af62/src/utils/operations/permute_cols.jl#L6-L38">source</a></section></details></article><h4 id="Transposition"><a class="docs-heading-anchor" href="#Transposition">Transposition</a><a id="Transposition-1"></a><a class="docs-heading-anchor-permalink" href="#Transposition" title="Permalink"></a></h4><p>Transposition exchanges rows and columns of a microstate. Let <span>$\mathcal{T}$</span> denote the transposition operator:</p><p class="math-container">\[\mathcal{T}\mathbf{M} = \begin{pmatrix}
a &amp; d &amp; g \\
b &amp; e &amp; f \\
c &amp; f &amp; i
\end{pmatrix}.\]</p><p>Using the same example microstate with identifier <span>$I = 237$</span>, transposition is performed via the <a href="#RecurrenceMicrostatesAnalysis.Transpose"><code>Transpose</code></a> operator:</p><pre><code class="language-julia hljs">transposition = Transpose(shape)
operate(transposition, 237)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">231</code></pre><p>The resulting microstate has decimal identifier <span>$I = 231$</span> corresponding to:</p><p class="math-container">\[\mathcal{T}\mathbf{M} = \begin{pmatrix}
0 &amp; 1 &amp; 1 \\
0 &amp; 0 &amp; 1 \\
1 &amp; 1 &amp; 0
\end{pmatrix}.\]</p><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis.Transpose"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis.Transpose"><code>RecurrenceMicrostatesAnalysis.Transpose</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Transpose{R, C} &lt;: Operation</code></pre><p>Operation that transposes a microstate <span>$\mathbf{M}$</span>.</p><p>To initialize a <code>Transpose</code> operation, a rectangular microstate shape must be provided via a <a href="../shapes_and_sampling/#RecurrenceMicrostatesAnalysis.Rect"><code>Rect</code></a> structure:</p><pre><code class="language-julia hljs">Transpose(::Rect2{R, C, B, E})</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Transpose(Rect(3, 3))     # 3 x 3 microstate</code></pre><p>This operation is applied via the <a href="#RecurrenceMicrostatesAnalysis.operate"><code>operate</code></a> function:</p><pre><code class="language-julia hljs">operate(::Transpose, I::Int)</code></pre><p><strong>Arguments</strong></p><ul><li><code>op</code>: A <code>Transpose</code> operation.</li><li><code>I</code>: DEcima identifier of the microstate (1-based).</li></ul><p><strong>Returns</strong></p><p>The resulting microstate decimal identifier (1-based).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/ef56ed683e529e7a8bb8bf0472a4899ba712af62/src/utils/operations/transpose.jl#L6-L32">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../gpu/">« GPU</a><a class="docs-footer-nextpage" href="../../examples/ml/">Machine Learning »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 10 January 2026 18:18">Saturday 10 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
