<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Distributions · RecurrenceMicrostatesAnalysis.jl</title><meta name="title" content="Distributions · RecurrenceMicrostatesAnalysis.jl"/><meta property="og:title" content="Distributions · RecurrenceMicrostatesAnalysis.jl"/><meta property="twitter:title" content="Distributions · RecurrenceMicrostatesAnalysis.jl"/><meta name="description" content="Documentation for RecurrenceMicrostatesAnalysis.jl."/><meta property="og:description" content="Documentation for RecurrenceMicrostatesAnalysis.jl."/><meta property="twitter:description" content="Documentation for RecurrenceMicrostatesAnalysis.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">RecurrenceMicrostatesAnalysis.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome</a></li><li><span class="tocitem">Tutorial</span><ul><li class="is-active"><a class="tocitem" href>Distributions</a><ul class="internal"><li><a class="tocitem" href="#Quick-start-with-RecurrenceMicrostatesAnalysis.jl"><span>Quick start with RecurrenceMicrostatesAnalysis.jl</span></a></li><li><a class="tocitem" href="#A-brief-review"><span>A brief review</span></a></li><li><a class="tocitem" href="#Computing-RMA-distributions"><span>Computing RMA distributions</span></a></li><li><a class="tocitem" href="#Histograms"><span>Histograms</span></a></li></ul></li><li><a class="tocitem" href="../quantifiers/">Quantifiers</a></li><li><a class="tocitem" href="../operations/">Operations</a></li><li><a class="tocitem" href="../recurrences/">Recurrence Functions</a></li><li><a class="tocitem" href="../shapes_and_sampling/">Shapes and Sampling</a></li><li><a class="tocitem" href="../gpu/">GPU</a></li><li><a class="tocitem" href="../tips/">Performance Tips</a></li><li><a class="tocitem" href="../utils/">Utils</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/ml/">Machine Learning</a></li></ul></li><li><a class="tocitem" href="../../dev/">Developers</a></li><li><a class="tocitem" href="../../refs/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li class="is-active"><a href>Distributions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Distributions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/main/docs/src/tutorial/distributions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Distributions"><a class="docs-heading-anchor" href="#Distributions">Distributions</a><a id="Distributions-1"></a><a class="docs-heading-anchor-permalink" href="#Distributions" title="Permalink"></a></h1><p>In this section, we introduce the computation of Recurrence Microstates Analysis (RMA) distributions using RecurrenceMicrostatesAnalysis.jl. We begin with a <a href="#Quick-start-with-RecurrenceMicrostatesAnalysis.jl">Quick start with RecurrenceMicrostatesAnalysis.jl</a>, which demonstrates a simple application example. Next, we present <a href="#A-brief-review">A brief review</a> of Recurrence Plots (RP) and RMA. Finally, we explain the <a href="#RecurrenceMicrostatesAnalysis.distribution"><code>distribution</code></a> function in <a href="#Computing-RMA-distributions">Computing RMA distributions</a>, describing how to use it, as well as the computation of <a href="#Histograms">Histograms</a>.</p><h2 id="Quick-start-with-RecurrenceMicrostatesAnalysis.jl"><a class="docs-heading-anchor" href="#Quick-start-with-RecurrenceMicrostatesAnalysis.jl">Quick start with RecurrenceMicrostatesAnalysis.jl</a><a id="Quick-start-with-RecurrenceMicrostatesAnalysis.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-start-with-RecurrenceMicrostatesAnalysis.jl" title="Permalink"></a></h2><p>Here we present quick examples of how to use the package. To compute an RMA distribution, you need to use the <a href="#RecurrenceMicrostatesAnalysis.distribution"><code>distribution</code></a> function, which returns a <a href="../../#ComplexityMeasures.Probabilities"><code>Probabilities</code></a> struct containing the microstate distribution.</p><p>We start with a simple example by computing the distribution of a uniform random process. First, we generate the data and convert it into a <a href="../../#StateSpaceSets.StateSpaceSet"><code>StateSpaceSet</code></a>:</p><pre><code class="language-julia hljs">using Distributions, RecurrenceMicrostatesAnalysis
data = rand(Uniform(0, 1), 10_000);
ssset = StateSpaceSet(data)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-dimensional StateSpaceSet{Float64} with 10000 points
 0.029144658477569862
 0.8008815421891382
 0.36532993514203205
 0.08678121027279939
 0.44999285975150627
 0.3559988942976584
 0.3785768510928773
 0.1189912683615234
 0.8199759322191083
 0.6295561037827448
 ⋮
 0.7429934300083132
 0.7681703371085256
 0.8507015581547324
 0.7017552940417643
 0.7703095208051542
 0.6613153079335161
 0.9647728425048318
 0.912509060947289
 0.3163410423894297</code></pre><p>Next, we use this <a href="../../#StateSpaceSets.StateSpaceSet"><code>StateSpaceSet</code></a> as input to compute the distribuion. We also need to specify the threshold, <span>$\varepsilon$</span>, and the microstate length, <span>$N$</span>. These parameters are explained in more detail in the sections <a href="#A-brief-review">A brief review</a> and <a href="../utils/#Optimizing-the-threshold">Optimizing the threshold</a>.</p><p>We will do here a &quot;fast example about how to use the package&quot;. To compute a RMA distribution with the package you need to use the function <a href="#RecurrenceMicrostatesAnalysis.distribution"><code>distribution</code></a>, which will result in a <a href="../../#ComplexityMeasures.Probabilities"><code>Probabilities</code></a> struct containg the distribution of microstates.</p><pre><code class="language-julia hljs">ε = 0.27
N = 2
dist = distribution(ssset, ε, N)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr33"> Probabilities{Float64,1} over 16 outcomes</span>
  <span class="sgr90">1</span>  0.10641554493486496
  <span class="sgr90">2</span>  0.048410154379721015
  <span class="sgr90">3</span>  0.048147849510234195
  <span class="sgr90">4</span>  0.08488673771773955
  <span class="sgr90">5</span>  0.04824328766640903
  <span class="sgr90">6</span>  0.08475008308321667
  <span class="sgr90">7</span>  0.07889654283782656
  <span class="sgr90">8</span>  0.030991190277873094
  <span class="sgr90">9</span>  0.04822568062711472
 <span class="sgr90">10</span>  0.07895416587551703
 <span class="sgr90">11</span>  0.08491594939656875
 <span class="sgr90">12</span>  0.0310276048364136
 <span class="sgr90">13</span>  0.08488533715779568
 <span class="sgr90">14</span>  0.03078330716620505
 <span class="sgr90">15</span>  0.030939569639942047
 <span class="sgr90">16</span>  0.07952699489255804</code></pre><p>As another example, we use the package <a href="https://juliadynamics.github.io/DynamicalSystemsDocs.jl/dynamicalsystems/stable/">DynamicalSystems.jl</a>. Following the same Hénon map example presented in its documentation, we compute a trajectory as follows:</p><pre><code class="language-julia hljs">using DynamicalSystems

function henon_rule(u, p, n) # here `n` is &quot;time&quot;, but we don&#39;t use it.
    x, y = u # system state
    a, b = p # system parameters
    xn = 1.0 - a*x^2 + y
    yn = b*x
    return SVector(xn, yn)
end

u0 = [0.2, 0.3]
p0 = [1.4, 0.3]

henon = DeterministicIteratedMap(henon_rule, u0, p0)

total_time = 10_000
X, t = trajectory(henon, total_time)
X</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-dimensional StateSpaceSet{Float64} with 10001 points
  0.2        0.3
  1.244      0.06
 -1.10655    0.3732
 -0.341035  -0.331965
  0.505208  -0.102311
  0.540361   0.151562
  0.742777   0.162108
  0.389703   0.222833
  1.01022    0.116911
 -0.311842   0.303065
  ⋮         
 -0.582534   0.328346
  0.853262  -0.17476
 -0.194038   0.255978
  1.20327   -0.0582113
 -1.08521    0.36098
 -0.287758  -0.325562
  0.558512  -0.0863275
  0.476963   0.167554
  0.849062   0.143089</code></pre><p>Finally, we compute the RMA distribution from the trajectory <code>X</code>. Here, we use the <a href="../utils/#RecurrenceMicrostatesAnalysis.optimize"><code>optimize</code></a> function to determine an appropriate threshold by maximizing the recurrence entropy:</p><pre><code class="language-julia hljs">ε, S = optimize(Threshold(), RecurrenceEntropy(), X, N)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.8437716954718881, 3.762746965651817)</code></pre><pre><code class="language-julia hljs">dist = distribution(X, ε, N)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr33"> Probabilities{Float64,1} over 16 outcomes</span>
  <span class="sgr90">1</span>  0.05377474419388994
  <span class="sgr90">2</span>  0.030079809946027217
  <span class="sgr90">3</span>  0.057340456623233324
  <span class="sgr90">4</span>  0.05205019962988605
  <span class="sgr90">5</span>  0.05720562968481103
  <span class="sgr90">6</span>  0.05225884131649504
  <span class="sgr90">7</span>  0.10716381132950363
  <span class="sgr90">8</span>  0.04051169423650845
  <span class="sgr90">9</span>  0.016107218222200795
 <span class="sgr90">10</span>  0.1355532835460525
 <span class="sgr90">11</span>  0.06622283132169808
 <span class="sgr90">12</span>  0.039175427250364624
 <span class="sgr90">13</span>  0.06619022480691643
 <span class="sgr90">14</span>  0.039079408065731534
 <span class="sgr90">15</span>  0.02651389747671585
 <span class="sgr90">16</span>  0.16077252234996553</code></pre><h2 id="A-brief-review"><a class="docs-heading-anchor" href="#A-brief-review">A brief review</a><a id="A-brief-review-1"></a><a class="docs-heading-anchor-permalink" href="#A-brief-review" title="Permalink"></a></h2><p>The concept of Recurrence Plots (RPs) was introduced in 1987 by Eckmann et al. (<a href="../../refs/#Eckmann1987RP">Eckmann <em>et al.</em>, 1987</a>) as a method for analyzing dynamical systems through recurrences. Let a time series <span>$\vec x_i \in \mathbb{R}^d$</span>, <span>$i \in \{1, 2, ..., K\}$</span> where <span>$K$</span> is the length of the time series and <span>$d$</span> is the dimension of the phase space (e.g., <span>$d = 3$</span> for the Lorenz system). The RP is defined as a graphical representation of the recurrence matrix</p><p class="math-container">\[R_{i,j} = \Theta(\varepsilon - \|\vec x_i - \vec x_j\|),\]</p><p>where <span>$\Theta(\cdot)$</span> denotes the Heaviside step function and <span>$\varepsilon$</span> is the threshold parameter that defines the maximum distance between two points for them to be considered <span>$\varepsilon$</span>-recurrent.</p><p>The following figure shows examples of recurrence plots for different systems: (a) white noise; (b) a superposition of harmonic oscillators; (c) a logistic map, <span>$x_{n+1} = 4x_n(1 - x_n)$</span>, with a linear trend added in time, <span>$y_n = x_n + \alpha n$</span>; (d) Brownian motion.</p><p><img src="../../assets/rps.png" alt="Image of four RPs with their timeseries"/></p><p>A recurrence microstate is a small local structure that can be identified within an RP. These structures form a closed set of microstates, determined by their shape and size. For example, considering square microstates of length <span>$N = 2$</span>, there are <span>$16$</span> possible microstates that can occur in an RP.</p><p><img src="../../assets/microstates.png" alt="Image of the 16 squared microstates to N = 2"/></p><p>Recurrence Microstates Analysis (RMA) uses the probability distribution of these microstates within an RP as a source of information for the analysis.  Accordingly, RecurrenceMicrostatesAnalysis.jl computes these distributions and applies them to the study of dynamical systems.</p><h2 id="Computing-RMA-distributions"><a class="docs-heading-anchor" href="#Computing-RMA-distributions">Computing RMA distributions</a><a id="Computing-RMA-distributions-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-RMA-distributions" title="Permalink"></a></h2><p>The computation of RMA distributions is the core of the RecurrenceMicrostatesAnalysis.jl package; all other functionalities rely on it as their primary source of information. Therefore, understanding how this tool works is essential in order to fully use the package and all that it has to offer.  RMA distributions are computed using the <a href="#RecurrenceMicrostatesAnalysis.distribution"><code>distribution</code></a> function, which provides several parameters that control its behaviour.</p><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis.distribution"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis.distribution"><code>RecurrenceMicrostatesAnalysis.distribution</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">distribution(core::RMACore, [x], [y])</code></pre><p>Compute an RMA distribution from a recurrence structure constructed using the input data <code>[x]</code> and <code>[y]</code>.   If <code>[x]</code> and <code>[y]</code> are identical, the result corresponds to a Recurrence Plot (RP); otherwise, it corresponds to a Cross-Recurrence Plot (CRP).</p><p>The <code>core</code> argument must be a structure inheriting from <a href="../../dev/#RecurrenceMicrostatesAnalysis.RMACore"><code>RMACore</code></a> and defines how the computation is performed, including whether a CPU or GPU backend is used, the microstate shape, the recurrence expression, and the sampling mode.</p><p>The output of <code>distribution</code> is a <a href="../../#ComplexityMeasures.Probabilities"><code>Probabilities</code></a> object, where each index corresponds to the decimal representation of the associated microstate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/acaff7c874cf44650b7bd32f7da79eab9cd6199b/src/core/abstract_core.jl#L26-L35">source</a></section><section><div><pre><code class="language-julia hljs">distribution(core::CPUCore, [x], [y]; kwargs...)</code></pre><p>Computes an RMA distribution using <code>[x]</code> and <code>[y]</code> as input and a CPU backend configuration specified by <code>core</code>, which must be a <a href="../../dev/#RecurrenceMicrostatesAnalysis.CPUCore"><code>CPUCore</code></a>.  The inputs <code>[x]</code> and <code>[y]</code> must be provided as <a href="../../#StateSpaceSets.StateSpaceSet"><code>StateSpaceSet</code></a> objects for time-series data, or as <code>AbstractArray</code>s for spatial data.</p><p><strong>Input</strong></p><ul><li><code>core</code>: A <a href="../../dev/#RecurrenceMicrostatesAnalysis.CPUCore"><code>CPUCore</code></a> defining the configuration of the <a href="../shapes_and_sampling/#RecurrenceMicrostatesAnalysis.MotifShape"><code>MotifShape</code></a>, <a href="../recurrences/#RecurrenceMicrostatesAnalysis.RecurrenceExpression"><code>RecurrenceExpression</code></a>, and <a href="../shapes_and_sampling/#RecurrenceMicrostatesAnalysis.SamplingMode"><code>SamplingMode</code></a>.</li><li><code>[x]</code>: Input data, given as a <a href="../../#StateSpaceSets.StateSpaceSet"><code>StateSpaceSet</code></a> or an <code>AbstractArray</code>.</li><li><code>[y]</code>: Input data, given as a <a href="../../#StateSpaceSets.StateSpaceSet"><code>StateSpaceSet</code></a> or an <code>AbstractArray</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>threads</code>: Number of threads which used to compute the distribution. By default, this is set to <code>Threads.nthreads()</code>, which can be specified at Julia startup using – using <code>--threads N</code> or via the environment variable <code>JULIA_NUM_THREADS</code>.</li></ul><p><strong>Examples</strong></p><ul><li>Time series:</li></ul><pre><code class="language-julia hljs">core = CPUCore(Rect(Standard(0.27), 2), SRandom(0.05))
dist = distribution(core, ssset, ssset)</code></pre><ul><li>Spatial data:</li></ul><pre><code class="language-julia hljs">spatialdata = rand(Uniform(0, 1), (3, 50, 50))
core = CPUCore(Rect(Standard(0.5), (2, 2, 1, 1)), SRandom(0.05))
dist = distribution(core, spatialdata, spatialdata)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/acaff7c874cf44650b7bd32f7da79eab9cd6199b/src/core/cpu_core.jl#L253-L280">source</a></section><section><div><pre><code class="language-julia hljs">distribution(core::GPUCore, [x], [y]; kwargs...)</code></pre><p>Compute an RMA distribution using <code>[x]</code> and <code>[y]</code> as input data and a GPU backend configuration specified by <code>core</code>, which must be a <a href="../../dev/#RecurrenceMicrostatesAnalysis.GPUCore"><code>GPUCore</code></a>.   The inputs <code>[x]</code> and <code>[y]</code> must be vectors inheriting from <code>AbstractGPUVector</code>. This method supports only time-series analysis.</p><div class="admonition is-info" id="Note-560028f845ba258e"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-560028f845ba258e" title="Permalink"></a></header><div class="admonition-body"><p>The output is copied from GPU memory back to the CPU.</p></div></div><p><strong>Input</strong></p><ul><li><code>core</code>: A <a href="../../dev/#RecurrenceMicrostatesAnalysis.GPUCore"><code>GPUCore</code></a> defining the configuration of the <a href="../shapes_and_sampling/#RecurrenceMicrostatesAnalysis.MotifShape"><code>MotifShape</code></a>, <a href="../recurrences/#RecurrenceMicrostatesAnalysis.RecurrenceExpression"><code>RecurrenceExpression</code></a>, and <a href="../shapes_and_sampling/#RecurrenceMicrostatesAnalysis.SamplingMode"><code>SamplingMode</code></a>.</li><li><code>[x]</code>: Input data, provided as an <code>AbstractGPUVector</code>.</li><li><code>[y]</code>: Input data, provided as an <code>AbstractGPUVector</code>.</li></ul><p><strong>Kwargs</strong></p><ul><li><code>groupsize</code>: Number of threads per workgroup on the GPU device.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using CUDA
gpudata = StateSpaceSet(Float32.(data)) |&gt; CuVector
core = GPUCore(CUDABackend(), Rect(Standard(0.27f0; metric = GPUEuclidean()), 2), SRandom(0.05))
dist = distribution(core, gpudata, gpudata)</code></pre><div class="admonition is-warning" id="Warning-b020c985c43b8e90"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-b020c985c43b8e90" title="Permalink"></a></header><div class="admonition-body"><p>Spatial data are not supported by <a href="../../dev/#RecurrenceMicrostatesAnalysis.GPUCore"><code>GPUCore</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/acaff7c874cf44650b7bd32f7da79eab9cd6199b/src/core/gpu/gpu_core.jl#L196-L223">source</a></section></details></article><p>The package implements several aliases to simplify the usage of the <a href="#RecurrenceMicrostatesAnalysis.distribution"><code>distribution</code></a> function. One of them was shown in the <a href="#Quick-start-with-RecurrenceMicrostatesAnalysis.jl">Quick start with RecurrenceMicrostatesAnalysis.jl</a> section:</p><pre><code class="language-julia hljs">distribution([x], ε::Float, n::Int; kwargs...)</code></pre><p>This method automatically uses a <a href="../../dev/#RecurrenceMicrostatesAnalysis.CPUCore"><code>CPUCore</code></a> when <code>[x]</code> is a <a href="../../#StateSpaceSets.StateSpaceSet"><code>StateSpaceSet</code></a>, or a <a href="../../dev/#RecurrenceMicrostatesAnalysis.GPUCore"><code>GPUCore</code></a> when <code>[x]</code> is an <code>AbstractGPUVector</code>. By default, it also uses <code>Square</code> microstates with side length <code>n</code>.</p><p>In addition to the keyword arguments of the default implementation, this method provides the following extra configurations:</p><ul><li><code>rate::Float64</code>: sampling rate, with default value <code>0.05</code>.</li><li><code>sampling::SamplingMode</code>: sampling mode; see <a href="../shapes_and_sampling/#Distribution-sampling">Distribution sampling</a>. The default is <a href="../shapes_and_sampling/#RecurrenceMicrostatesAnalysis.SRandom"><code>SRandom</code></a>.</li><li><code>metric::Metric</code>: metric used to compute recurrences, based on the package <a href="https://github.com/JuliaStats/Distances.jl">Distances.jl</a>. When using a <a href="../../dev/#RecurrenceMicrostatesAnalysis.GPUCore"><code>GPUCore</code></a>, a <a href="../gpu/#RecurrenceMicrostatesAnalysis.GPUMetric"><code>GPUMetric</code></a> must be used; see <a href="../gpu/#Metrics-for-GPU">Metrics for GPU</a>.</li></ul><div class="admonition is-warning" id="Warning-9fde982c30edf477"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-9fde982c30edf477" title="Permalink"></a></header><div class="admonition-body"><p>When using GPU backend, inputs must be of type <code>Float32</code>. The package is not compatible with <code>Float64</code> on GPU.</p></div></div><p>It is also possible to specify the <a href="../recurrences/#RecurrenceMicrostatesAnalysis.RecurrenceExpression"><code>RecurrenceExpression</code></a> directly instead of providing the threshold explicitly:</p><pre><code class="language-julia hljs">distribution([x], expr::RecurrenceExpression, n::Int; kwargs...)</code></pre><p>In this case, the keyword arguments remain the same, except for <code>metric</code>, which is already defined within the <a href="../recurrences/#RecurrenceMicrostatesAnalysis.RecurrenceExpression"><code>RecurrenceExpression</code></a>.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">expr = Corridor(0.05, 0.27)
dist = distribution(ssset, expr, 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr33"> Probabilities{Float64,1} over 16 outcomes</span>
  <span class="sgr90">1</span>  0.17182289479333837
  <span class="sgr90">2</span>  0.0826704516465683
  <span class="sgr90">3</span>  0.08280610588113127
  <span class="sgr90">4</span>  0.0632042690667729
  <span class="sgr90">5</span>  0.08261222836890189
  <span class="sgr90">6</span>  0.06328770242342889
  <span class="sgr90">7</span>  0.05768686320791052
  <span class="sgr90">8</span>  0.024299715026067422
  <span class="sgr90">9</span>  0.08282651404031331
 <span class="sgr90">10</span>  0.057491184975753305
 <span class="sgr90">11</span>  0.06362003529010898
 <span class="sgr90">12</span>  0.02427930686688538
 <span class="sgr90">13</span>  0.06329890690297982
 <span class="sgr90">14</span>  0.024250295268048165
 <span class="sgr90">15</span>  0.02423889070850526
 <span class="sgr90">16</span>  0.031604635533286206</code></pre><p>If a different <a href="../shapes_and_sampling/#RecurrenceMicrostatesAnalysis.MotifShape"><code>MotifShape</code></a> is desired, the function call can be simplified to:</p><pre><code class="language-julia hljs">distribution([x], shape::MotifShape; kwargs...)</code></pre><p>Here, <code>shape</code> constains the information about both the <a href="../recurrences/#RecurrenceMicrostatesAnalysis.RecurrenceExpression"><code>RecurrenceExpression</code></a> and the microstate size <code>n</code>.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">shape = Triangle(Standard(0.27), 3)
dist = distribution(ssset, shape)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr33"> Probabilities{Float64,1} over 64 outcomes</span>
  <span class="sgr90">1</span>  0.031262551278256695
  <span class="sgr90">2</span>  0.026849504332698754
  <span class="sgr90">3</span>  0.014035618564014696
  <span class="sgr90">4</span>  0.01299059175693581
  <span class="sgr90">5</span>  0.01494796578988077
  <span class="sgr90">6</span>  0.01196697779328041
  <span class="sgr90">7</span>  0.024847903772682856
  <span class="sgr90">8</span>  0.02295196658956042
  <span class="sgr90">9</span>  0.0133363991722235
 <span class="sgr90">10</span>  0.011785068684196782
  ⋮  
 <span class="sgr90">56</span>  0.007133278540468573
 <span class="sgr90">57</span>  0.021053427846022044
 <span class="sgr90">58</span>  0.020009401639103135
 <span class="sgr90">59</span>  0.0076023598954653
 <span class="sgr90">60</span>  0.008069440050142075
 <span class="sgr90">61</span>  0.008183508468379334
 <span class="sgr90">62</span>  0.007534319084586935
 <span class="sgr90">63</span>  0.019751246797829337
 <span class="sgr90">64</span>  0.0195863478914653</code></pre><p>The package also provides implementations for computing RMA distributions from Cross-Recurrence Plots (CRPs).  In this case, the workflow is similar, but two time series must be provided as input:</p><pre><code class="language-julia hljs">distribution([x], [y], expr::RecurrenceExpression, n::Int; kwargs...)
distribution([x], [y], expr::RecurrenceExpression, n::Int; kwargs...)
distribution([x], [y], shape::MotifShape; kwargs...)</code></pre><p><strong>Example:</strong></p><pre><code class="language-julia hljs">data_1 = StateSpaceSet(rand(Uniform(0, 1), 1000))
data_2 = StateSpaceSet(rand(Uniform(0, 1), 2000))
dist = distribution(data_1, data_2, 0.27, 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr33"> Probabilities{Float64,1} over 16 outcomes</span>
  <span class="sgr90">1</span>  0.11128273537878255
  <span class="sgr90">2</span>  0.05105264741577316
  <span class="sgr90">3</span>  0.04898646954393637
  <span class="sgr90">4</span>  0.08429203317920582
  <span class="sgr90">5</span>  0.04934754917202435
  <span class="sgr90">6</span>  0.08574638168122686
  <span class="sgr90">7</span>  0.0769099607827404
  <span class="sgr90">8</span>  0.030240418852368584
  <span class="sgr90">9</span>  0.04915697936831125
 <span class="sgr90">10</span>  0.07602732169185866
 <span class="sgr90">11</span>  0.08675941063780704
 <span class="sgr90">12</span>  0.03052125856310368
 <span class="sgr90">13</span>  0.08286777464619212
 <span class="sgr90">14</span>  0.03050119858376546
 <span class="sgr90">15</span>  0.03005987903832459
 <span class="sgr90">16</span>  0.07624798146457909</code></pre><div class="admonition is-danger" id="Danger-1b04633bfc9f9e56"><header class="admonition-header">Danger<a class="admonition-anchor" href="#Danger-1b04633bfc9f9e56" title="Permalink"></a></header><div class="admonition-body"><p>Note that <code>[x]</code> and <code>[y]</code> must have the same phase-space dimensionality. The following example is invalid because <code>data_1</code> has 2 dimensions while <code>data_2</code> has 3, which results in an exception:</p><pre><code class="language-julia hljs">data_1 = StateSpaceSet(rand(Uniform(0, 1), (1000, 2)))
data_2 = StateSpaceSet(rand(Uniform(0, 1), (2000, 3)))
dist = distribution(data_1, data_2, 0.27, 2)</code></pre></div></div><h3 id="Spatial-data"><a class="docs-heading-anchor" href="#Spatial-data">Spatial data</a><a id="Spatial-data-1"></a><a class="docs-heading-anchor-permalink" href="#Spatial-data" title="Permalink"></a></h3><p>RecurrenceMicrostatesAnalysis.jl also provides support for spatial data, following the work <em>&quot;Generalised Recurrence Plot Analysis for Spatial Data&quot;</em> (<a href="../../refs/#Marwan2007Spatial">Marwan <em>et al.</em>, 2007</a>). This implementation represents an open research direction and is included in the package primarily for exploratory purposes. For this reason, support for spatial data analysis is partial, as many of its theoretical aspects have not yet been fully developed.</p><p>In this context, the application interface is</p><pre><code class="language-julia hljs">distribution([x], shape::MotifShape; kwargs...)</code></pre><p>which was introduced earlier. The implementation is the same, but here <code>[x]</code> is an <code>AbstractArray</code>. The input data are defined as</p><p class="math-container">\[\vec{x}_{\vec i} \in \mathbb{R}^m, \vec{i} \in \mathbb{Z}^d.\]</p><p>Within the package context, this can be provided as, for example, <span>$m = 2$</span>, <span>$d = 2$</span>, and <span>$\vec{i} \in [1, K]^d$</span> with <span>$K = 50$</span>:</p><pre><code class="language-julia hljs">spatialdata = rand(Uniform(0, 1), (2, 50, 50))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×50×50 Array{Float64, 3}:
[:, :, 1] =
 0.191465  0.80482  0.266185  0.229756   …  0.542583  0.652905  0.782441
 0.900251  0.44173  0.395713  0.0657188     0.751247  0.463963  0.557323

[:, :, 2] =
 0.335118  0.225581  0.489151  0.755009  …  0.552484  0.150023  0.594641
 0.927228  0.368527  0.726454  0.600169     0.476467  0.400852  0.557425

[:, :, 3] =
 0.601386  0.343266   0.493749  0.606258  …  0.675701  0.428793  0.594589
 0.294039  0.0246807  0.492621  0.576405     0.892824  0.467085  0.216999

;;; … 

[:, :, 48] =
 0.523809  0.691528  0.235847  0.915737  …  0.733105  0.492781  0.469004
 0.910976  0.707378  0.508361  0.152119     0.39009   0.094199  0.423551

[:, :, 49] =
 0.200467  0.0683174  0.741528  0.500714  …  0.18772   0.815573  0.530579
 0.273689  0.821754   0.698596  0.385083     0.907482  0.309872  0.162709

[:, :, 50] =
 0.493194  0.684787  0.269384   0.360293  …  0.435942  0.655461  0.390664
 0.190338  0.267956  0.0133729  0.628281     0.748692  0.776875  0.440339</code></pre><p>The resulting recurrence plot has dimension <span>$2 \times d$</span>, forming a tensorial structure that cannot be directly visualized and can be computationally demanding. In this situation, the RMA distribution can be defined to avoid memory limitations, although the cost of increased complexity. Specifically, the microstates may themselves become tensorial objects of dimension <span>$2 \times d$</span>, or projections onto lower-dimensional subspaces. This bevaviour is specified through the <a href="../shapes_and_sampling/#RecurrenceMicrostatesAnalysis.MotifShape"><code>MotifShape</code></a>.</p><p><strong>Example:</strong></p><ul><li>Microstate with <span>$N = 2$</span> and full <span>$2 \times d$</span> dimensionality:</li></ul><pre><code class="language-julia hljs">distribution(spatialdata, Rect(Standard(0.27), (2, 2, 2, 2)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr33"> Probabilities{Float64,1} over 65536 outcomes</span>
     <span class="sgr90">1</span>  0.05488638804013247
     <span class="sgr90">2</span>  0.00852230983983935
     <span class="sgr90">3</span>  0.008793576996545111
     <span class="sgr90">4</span>  0.002139996458456565
     <span class="sgr90">5</span>  0.008571288632022334
     <span class="sgr90">6</span>  0.0025657351905086635
     <span class="sgr90">7</span>  0.002490383202534841
     <span class="sgr90">8</span>  0.0008740830604963435
     <span class="sgr90">9</span>  0.008906604978505846
    <span class="sgr90">10</span>  0.0024037284163649446
     ⋮  
 <span class="sgr90">65528</span>  0.0
 <span class="sgr90">65529</span>  0.0
 <span class="sgr90">65530</span>  0.0
 <span class="sgr90">65531</span>  0.0
 <span class="sgr90">65532</span>  0.0
 <span class="sgr90">65533</span>  0.0
 <span class="sgr90">65534</span>  0.0
 <span class="sgr90">65535</span>  0.0
 <span class="sgr90">65536</span>  0.0</code></pre><ul><li>Microstate with <span>$N = 2$</span> projected onto the first and third dimensions:</li></ul><pre><code class="language-julia hljs">distribution(spatialdata, Rect(Standard(0.27), (2, 1, 2, 1)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr33"> Probabilities{Float64,1} over 16 outcomes</span>
  <span class="sgr90">1</span>  0.456651578475466
  <span class="sgr90">2</span>  0.09576783467584492
  <span class="sgr90">3</span>  0.09580760386990413
  <span class="sgr90">4</span>  0.023901285629582495
  <span class="sgr90">5</span>  0.09625952652966782
  <span class="sgr90">6</span>  0.023904901010860607
  <span class="sgr90">7</span>  0.022574440700516278
  <span class="sgr90">8</span>  0.0032176893375175345
  <span class="sgr90">9</span>  0.0975719099336216
 <span class="sgr90">10</span>  0.02306251717306107
 <span class="sgr90">11</span>  0.024345977526789974
 <span class="sgr90">12</span>  0.0031634586183458906
 <span class="sgr90">13</span>  0.02415074693777206
 <span class="sgr90">14</span>  0.0031092278991742468
 <span class="sgr90">15</span>  0.0032249201000737536
 <span class="sgr90">16</span>  0.003286381581801617</code></pre><p>RecurrenceMicrostatesAnalysis.jl also supports a spatial analogue of the Cross-Recurrence Plot (CRP) used for time series, referred to here as the Croos-Spatial Recurrence Plot (CSRP). This functionality arises naturally from the package structure and can be invoked as</p><pre><code class="language-julia hljs">distribution([x], [y], shape::MotifShape; kwargs...)</code></pre><p><strong>Example:</strong></p><ul><li>Microstate <span>$N = 2$</span> and full <span>$2\times d$</span> dimensionality:</li></ul><pre><code class="language-julia hljs">spatialdata_1 = rand(Uniform(0, 1), (2, 50, 50))
spatialdata_2 = rand(Uniform(0, 1), (2, 25, 25))
distribution(spatialdata_1, spatialdata_2, Rect(Standard(0.27), (2, 2, 2, 2)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr33"> Probabilities{Float64,1} over 65536 outcomes</span>
     <span class="sgr90">1</span>  0.0544789222362613
     <span class="sgr90">2</span>  0.008582071183603813
     <span class="sgr90">3</span>  0.00822106627721895
     <span class="sgr90">4</span>  0.0020839828686762605
     <span class="sgr90">5</span>  0.0090251226596216
     <span class="sgr90">6</span>  0.002313713263648447
     <span class="sgr90">7</span>  0.002838811309299158
     <span class="sgr90">8</span>  0.0009353308938153295
     <span class="sgr90">9</span>  0.008549252555750644
    <span class="sgr90">10</span>  0.0023957598332813705
     ⋮  
 <span class="sgr90">65528</span>  0.0
 <span class="sgr90">65529</span>  0.0
 <span class="sgr90">65530</span>  0.0
 <span class="sgr90">65531</span>  0.0
 <span class="sgr90">65532</span>  0.0
 <span class="sgr90">65533</span>  0.0
 <span class="sgr90">65534</span>  0.0
 <span class="sgr90">65535</span>  0.0
 <span class="sgr90">65536</span>  0.0</code></pre><ul><li>Microstate <span>$N = 2$</span> projected onto the first and third dimensions:</li></ul><pre><code class="language-julia hljs">distribution(spatialdata_1, spatialdata_2, Rect(Standard(0.27), (2, 1, 2, 1)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr33"> Probabilities{Float64,1} over 16 outcomes</span>
  <span class="sgr90">1</span>  0.4567441000677799
  <span class="sgr90">2</span>  0.09432189290775772
  <span class="sgr90">3</span>  0.09646312157249369
  <span class="sgr90">4</span>  0.024092673608971594
  <span class="sgr90">5</span>  0.09540020950150964
  <span class="sgr90">6</span>  0.027404646004066793
  <span class="sgr90">7</span>  0.02232115349066486
  <span class="sgr90">8</span>  0.003435208577238277
  <span class="sgr90">9</span>  0.09507671452338406
 <span class="sgr90">10</span>  0.02205927660361082
 <span class="sgr90">11</span>  0.026110666091564483
 <span class="sgr90">12</span>  0.00308090455357693
 <span class="sgr90">13</span>  0.023630537925935054
 <span class="sgr90">14</span>  0.0028498367120586604
 <span class="sgr90">15</span>  0.003481422145541931
 <span class="sgr90">16</span>  0.003527635713845585</code></pre><h2 id="Histograms"><a class="docs-heading-anchor" href="#Histograms">Histograms</a><a id="Histograms-1"></a><a class="docs-heading-anchor-permalink" href="#Histograms" title="Permalink"></a></h2><p>The <a href="#RecurrenceMicrostatesAnalysis.histogram"><code>histogram</code></a> function is responsible for counting the occurrences of each microstate identified during the sampling process.  It is internally called by the <a href="#RecurrenceMicrostatesAnalysis.distribution"><code>distribution</code></a> function, which takes the resulting <a href="../../#ComplexityMeasures.Counts"><code>Counts</code></a> and returns the corresponding <a href="../../#ComplexityMeasures.Probabilities"><code>Probabilities</code></a>.</p><p>This function is also responsible for implementing the backend.</p><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis.histogram"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis.histogram"><code>RecurrenceMicrostatesAnalysis.histogram</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">histogram(core::RMACore, [x], [y])</code></pre><p>Compute the histogram of recurrence microstates using the input data <code>[x]</code> and <code>[y]</code> for a given <code>core</code>, which must be an <a href="../../dev/#RecurrenceMicrostatesAnalysis.RMACore"><code>RMACore</code></a>.   This function implements the backend, executing the sampling process, constructing the microstates, and computing the recurrences.</p><p>The output is a <a href="../../#ComplexityMeasures.Counts"><code>Counts</code></a> object, where each index corresponds to the decimal representation of the associated microstate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/acaff7c874cf44650b7bd32f7da79eab9cd6199b/src/core/abstract_core.jl#L14-L21">source</a></section><section><div><pre><code class="language-julia hljs">histogram(core::StandardCPUCore, [x], [y]; kwargs...)</code></pre><p>Count the microstates of an &quot;abstract&quot; RP constructed using <code>[x]</code> and <code>[y]</code>. If <code>[x]</code> and <code>[y]</code> are identical, the result corresponds to a Recurrence Plot (RP); otherwise, it corresponds to a Cross-Recurrence Plot (CRP). The output is a histogram of recurrence microstates for the given input data as a <a href="../../#ComplexityMeasures.Counts"><code>Counts</code></a> structure.</p><p>This method implements the CPU backend, based on a <a href="../../dev/#RecurrenceMicrostatesAnalysis.CPUCore"><code>CPUCore</code></a>, specifically a <a href="../../dev/#RecurrenceMicrostatesAnalysis.StandardCPUCore"><code>StandardCPUCore</code></a>.</p><p><strong>Input</strong></p><ul><li><code>core</code>: A <a href="../../dev/#RecurrenceMicrostatesAnalysis.StandardCPUCore"><code>StandardCPUCore</code></a>, which defines how the backend computation is performed.</li><li><code>[x]</code>: Input data, provided as a <a href="../../#StateSpaceSets.StateSpaceSet"><code>StateSpaceSet</code></a> or an <code>AbstractArray</code>.</li><li><code>[y]</code>: Input data, provided as a <a href="../../#StateSpaceSets.StateSpaceSet"><code>StateSpaceSet</code></a> or an <code>AbstractArray</code>.</li></ul><div class="admonition is-info" id="Note-9ae0cd875ee96070"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-9ae0cd875ee96070" title="Permalink"></a></header><div class="admonition-body"><p><a href="../../#StateSpaceSets.StateSpaceSet"><code>StateSpaceSet</code></a> and <code>AbstractArray</code> use different backends and therefore different internal histogram implementations.   However, both functions share the same method signature, differing only in the input data format.</p></div></div><p><strong>Keyword Arguments</strong></p><ul><li><code>threads</code>: Number of threads used to compute the histogram. By default, this is set to <code>Threads.nthreads()</code>, which can be specified at Julia startup using – using <code>--threads N</code> or via the environment variable <code>JULIA_NUM_THREADS</code>.</li></ul><p><strong>Examples</strong></p><ul><li>Time series:</li></ul><pre><code class="language-julia hljs">core = CPUCore(Rect(Standard(0.27), 2), SRandom(0.05))
dist = histogram(core, ssset, ssset)</code></pre><ul><li>Spatial data:</li></ul><pre><code class="language-julia hljs">spatialdata = rand(Uniform(0, 1), (3, 50, 50))
core = CPUCore(Rect(Standard(0.5), (2, 2, 1, 1)), SRandom(0.05))
dist = histogram(core, spatialdata, spatialdata)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/acaff7c874cf44650b7bd32f7da79eab9cd6199b/src/core/cpu_core.jl#L50-L84">source</a></section><section><div><pre><code class="language-julia hljs">histogram(core::StandardGPUCore, [x], [y]; kwargs...)</code></pre><p>Count the microstates of an &quot;abstract&quot; RP constructed using <code>[x]</code> and <code>[y]</code>. If <code>[x]</code> and <code>[y]</code> are identical, the result corresponds to a Recurrence Plot (RP); otherwise, it corresponds to a Cross-Recurrence Plot (CRP). The output is a histogram of recurrence microstates for the given input data as a <a href="../../#ComplexityMeasures.Counts"><code>Counts</code></a> structure.</p><div class="admonition is-info" id="Note-560028f845ba258e"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-560028f845ba258e" title="Permalink"></a></header><div class="admonition-body"><p>The output is copied from GPU memory back to the CPU.</p></div></div><p>This method implements the GPU backend, based on a <a href="../../dev/#RecurrenceMicrostatesAnalysis.GPUCore"><code>GPUCore</code></a>, specifically a <a href="../../dev/#RecurrenceMicrostatesAnalysis.StandardGPUCore"><code>StandardGPUCore</code></a>.</p><p><strong>Input</strong></p><ul><li><code>core</code>: A <a href="../../dev/#RecurrenceMicrostatesAnalysis.StandardGPUCore"><code>StandardGPUCore</code></a>, which defines how the backend computation is performed.</li><li><code>[x]</code>: Input data, provided as an <code>AbstractGPUVector</code>.</li><li><code>[y]</code>: Input data, provided as an <code>AbstractGPUVector</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>groupsize</code>: Number of threads per workgroup on the GPU device.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using CUDA
gpudata = StateSpaceSet(Float32.(data)) |&gt; CuVector
core = GPUCore(CUDABackend(), Rect(Standard(0.27f0; metric = GPUEuclidean()), 2), SRandom(0.05))
dist = histogram(core, gpudata, gpudata)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/acaff7c874cf44650b7bd32f7da79eab9cd6199b/src/core/gpu/gpu_core.jl#L43-L70">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Welcome</a><a class="docs-footer-nextpage" href="../quantifiers/">Quantifiers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 23 December 2025 17:52">Tuesday 23 December 2025</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
