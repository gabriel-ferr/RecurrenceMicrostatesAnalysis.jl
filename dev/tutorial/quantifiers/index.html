<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quantifiers · RecurrenceMicrostatesAnalysis.jl</title><meta name="title" content="Quantifiers · RecurrenceMicrostatesAnalysis.jl"/><meta property="og:title" content="Quantifiers · RecurrenceMicrostatesAnalysis.jl"/><meta property="twitter:title" content="Quantifiers · RecurrenceMicrostatesAnalysis.jl"/><meta name="description" content="Documentation for RecurrenceMicrostatesAnalysis.jl."/><meta property="og:description" content="Documentation for RecurrenceMicrostatesAnalysis.jl."/><meta property="twitter:description" content="Documentation for RecurrenceMicrostatesAnalysis.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">RecurrenceMicrostatesAnalysis.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../distributions/">Distributions</a></li><li class="is-active"><a class="tocitem" href>Quantifiers</a><ul class="internal"><li><a class="tocitem" href="#Recurrence-microstates-entropy"><span>Recurrence microstates entropy</span></a></li><li><a class="tocitem" href="#Recurrence-rate"><span>Recurrence rate</span></a></li><li><a class="tocitem" href="#Determinism"><span>Determinism</span></a></li><li><a class="tocitem" href="#Laminarity"><span>Laminarity</span></a></li><li><a class="tocitem" href="#Disorder"><span>Disorder</span></a></li></ul></li><li><a class="tocitem" href="../recurrences/">Recurrence Functions</a></li><li><a class="tocitem" href="../shapes_and_sampling/">Shapes and Sampling</a></li><li><a class="tocitem" href="../gpu/">GPU</a></li><li><a class="tocitem" href="../utils/">Utils</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/ml/">Machine Learning</a></li></ul></li><li><a class="tocitem" href="../../dev/">Developers</a></li><li><a class="tocitem" href="../../refs/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li class="is-active"><a href>Quantifiers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quantifiers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/main/docs/src/tutorial/quantifiers.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Quantifiers"><a class="docs-heading-anchor" href="#Quantifiers">Quantifiers</a><a id="Quantifiers-1"></a><a class="docs-heading-anchor-permalink" href="#Quantifiers" title="Permalink"></a></h1><p>Quantifiers are measures used to characterize specific properties of a dynamical system. Currently, Recurrence Microstates Analysis (RMA) provides five quantifiers that can be computed or estimated from a microstate distribution.</p><p>Three of these correspond to classical Recurrence Quantification Analysis (RQA) measures: <strong>recurrence rate</strong>, <strong>determinism</strong>, and <strong>laminarity</strong>. One is an information-theoretic entropy measure. The final quantifier is <strong>disorder</strong>, which is defined directly in terms of the microstate distribution and exploits symmetry properties of recurrence structures.</p><p>All quantifiers implemented in the package inherit from <a href="#RecurrenceMicrostatesAnalysis.QuantificationMeasure"><code>QuantificationMeasure</code></a>, and their computation is performed using the <a href="#RecurrenceMicrostatesAnalysis.measure"><code>measure</code></a> function.</p><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis.QuantificationMeasure"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis.QuantificationMeasure"><code>RecurrenceMicrostatesAnalysis.QuantificationMeasure</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">QuantificationMeasure</code></pre><p>Abstract supertype defining an RQA or RMA quantification measure.</p><p>All quantifiers implemented in the package subtype <code>QuantificationMeasure</code> and define their computation via the <a href="#RecurrenceMicrostatesAnalysis.measure"><code>measure</code></a> function.</p><p><strong>Implementations</strong></p><ul><li><a href="#Determinism"><code>Determinism</code></a></li><li><a href="#Disorder"><code>Disorder</code></a></li><li><a href="#Laminarity"><code>Laminarity</code></a></li><li><a href="#RecurrenceMicrostatesAnalysis.RecurrenceEntropy"><code>RecurrenceEntropy</code></a></li><li><a href="#RecurrenceMicrostatesAnalysis.RecurrenceRate"><code>RecurrenceRate</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/a48ba3b446fc827628e146e8fd19521c95a2cc3e/src/core/measures.jl#L6-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis.measure"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis.measure"><code>RecurrenceMicrostatesAnalysis.measure</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">measure(qm::QuantificationMeasure, [...])</code></pre><p>Compute the quantification measure defined by the given <a href="#RecurrenceMicrostatesAnalysis.QuantificationMeasure"><code>QuantificationMeasure</code></a> instance.</p><p>The accepted arguments (<code>[...]</code>) depend on the specific quantifier implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/a48ba3b446fc827628e146e8fd19521c95a2cc3e/src/core/measures.jl#L26-L32">source</a></section></details></article><h2 id="Recurrence-microstates-entropy"><a class="docs-heading-anchor" href="#Recurrence-microstates-entropy">Recurrence microstates entropy</a><a id="Recurrence-microstates-entropy-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrence-microstates-entropy" title="Permalink"></a></h2><p>The Recurrence Microstates Entropy (RME) was introduced in 2018 and marks the starting point of the RMA framework (<a href="../../refs/#Corso2018Entropy">Corso <em>et al.</em>, 2018</a>). It is defined as the Shannon entropy of the RMA distribution:</p><p class="math-container">\[RME = -\sum_{i = 1}^{2^\sigma} p_i^{(N)} \ln p_i^{(N)},\]</p><p>where <span>$n$</span> is the microstate size, <span>$\sigma$</span> is the number of recurrence elements constrained within the microstate (e.g. <span>$\sigma = n^2$</span> for square microstates), and <span>$p_i^{(N)}$</span> denotes the probability of the microstate with decimal representation <span>$i$</span>.</p><p>In <strong>RecurrenceMicrostatesAnalysis.jl</strong>, the RME is implemented by the <a href="#RecurrenceMicrostatesAnalysis.RecurrenceEntropy"><code>RecurrenceEntropy</code></a> struct.</p><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis.RecurrenceEntropy"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis.RecurrenceEntropy"><code>RecurrenceMicrostatesAnalysis.RecurrenceEntropy</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RecurrenceEntropy &lt;: QuantificationMeasure</code></pre><p>Define the <em>Recurrence Microstates Entropy</em> (RME) quantification measure (<a href="../../refs/#Corso2018Entropy">Corso <em>et al.</em>, 2018</a>).</p><p>RME can be computed either from a distribution of recurrence microstates or directly from time-series data. In both cases, the computation is performed via the <a href="#RecurrenceMicrostatesAnalysis.measure"><code>measure</code></a> function.</p><p><strong>Using a distribution</strong></p><pre><code class="language-julia hljs">measure(::RecurrenceEntropy, dist::Probabilities)</code></pre><p><strong>Arguments</strong></p><ul><li><code>dist</code>: A distribution of recurrence microstates.</li></ul><p><strong>Returns</strong></p><p>A <code>Float64</code> corresponding to the RME computed using the Shannon entropy.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using RecurrenceMicrostatesAnalysis, Distributions
data = StateSpaceSet(rand(Uniform(0, 1), 1000))
dist = distribution(data, 0.27, 3)
rme = measure(RecurrenceEntropy(), dist)</code></pre><p><strong>Using a time series</strong></p><pre><code class="language-julia hljs">measure(::RecurrenceEntropy, [x]; kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>[x]</code>: Time-series data provided as an <a href="../../#StateSpaceSets.StateSpaceSet"><code>StateSpaceSet</code></a>.</li></ul><p><strong>Returns</strong></p><p>A <code>Float64</code> corresponding to the <strong>maximum</strong> RME computed using the Shannon entropy.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>N</code>: Integer defining the microstate size. The default value is <code>3</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using RecurrenceMicrostatesAnalysis, Distributions
data = StateSpaceSet(rand(Uniform(0, 1), 1000))
rme = measure(RecurrenceEntropy(), data; N = 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/a48ba3b446fc827628e146e8fd19521c95a2cc3e/src/rqa/entropy.jl#L6-L52">source</a></section></details></article><p>Since the output of the <a href="../distributions/#RecurrenceMicrostatesAnalysis.distribution"><code>distribution</code></a> function is a <a href="../../#ComplexityMeasures.Probabilities"><code>Probabilities</code></a> object, the package also supports other information or complexity measures provided by <a href="https://juliadynamics.github.io/DynamicalSystemsDocs.jl/complexitymeasures/stable/">ComplexityMeasures.jl</a>.</p><h3 id="Quick-example"><a class="docs-heading-anchor" href="#Quick-example">Quick example</a><a id="Quick-example-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-example" title="Permalink"></a></h3><p>As an example, consider a uniform random process. The RME as a function of the threshold can be computed and visualized as follows:</p><pre><code class="language-julia hljs">using RecurrenceMicrostatesAnalysis, Distributions, CairoMakie

data_len = 10000
resolution = 50

data = StateSpaceSet(rand(Uniform(0, 1), data_len))
thres_range = range(0, 1, resolution)
results = zeros(Float64, resolution)

for i ∈ eachindex(results)
    dist = distribution(data, thres_range[i], 4)
    results[i] = measure(RecurrenceEntropy(), dist)
end

results ./= maximum(results)
scatterlines(thres_range, results)</code></pre><img src="fe39a722.png" alt="Example block output"/><h2 id="Recurrence-rate"><a class="docs-heading-anchor" href="#Recurrence-rate">Recurrence rate</a><a id="Recurrence-rate-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrence-rate" title="Permalink"></a></h2><p>The Recurrence Rate (RR) quantifies the density of recurrence points in a recurrence plot (<a href="../../refs/#Webber2015Recurrence">Webber and Marwan, 2015</a>). In standard RQA, it is defined as</p><p class="math-container">\[RR = \frac{1}{K^2} \sum_{i,j=1}^K R_{i,j}.\]</p><p>where <span>$K$</span> is the length of the time series.</p><p>When estimated using RMA, RR is defined as the expected recurrence rate over the microstate distribution:</p><p class="math-container">\[RR = \sum_{i = 1}^{2^\sigma} p_i^{(N)} RR_i^{(N)},\]</p><p>where <span>$RR_i^{(N)}$</span> denotes the recurrence rate of the <span>$i$</span>-th microstate. For square microstates, this quantity is given by</p><p class="math-container">\[RR_i^{(N)} = \frac{1}{\sigma} \sum_{j,k=1}^N M_{j,k}^{i, (N)},\]</p><p>with <span>$\mathbf{M}^{i, (N)}$</span> denoting the microstate structure corresponding to index <span>$i$</span>.</p><p>In <strong>RecurrenceMicrostatesAnalysis.jl</strong>, RR is implemented by <a href="#RecurrenceMicrostatesAnalysis.RecurrenceRate"><code>RecurrenceRate</code></a> struct.</p><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis.RecurrenceRate"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis.RecurrenceRate"><code>RecurrenceMicrostatesAnalysis.RecurrenceRate</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RecurrenceRate &lt;: QuantificationMeasure</code></pre><p>Define the <em>Recurrence Rate</em> (RR) quantification measure.</p><p>RR can be computed either from a distribution of recurrence microstates or directly from time-series data. In both cases, the computation is performed via the <a href="#RecurrenceMicrostatesAnalysis.measure"><code>measure</code></a> function.</p><p><strong>Using a distribution</strong></p><pre><code class="language-julia hljs">measure(::RecurrenceRate, dist::Probabilities)</code></pre><p><strong>Arguments</strong></p><ul><li><code>dist</code>: A distribution of recurrence microstates.</li></ul><p><strong>Returns</strong></p><p>A <code>Float64</code> corresponding to the estimated recurrence rate.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using RecurrenceMicrostatesAnalysis, Distributions
data = StateSpaceSet(rand(Uniform(0, 1), 1000))
dist = distribution(data, 0.27, 3)
rr = measure(RecurrenceRate(), dist)</code></pre><p><strong>Using a time series</strong></p><pre><code class="language-julia hljs">measure(::RecurrenceRate, [x]; kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>[x]</code>: Time-series data provided as a <a href="../../#StateSpaceSets.StateSpaceSet"><code>StateSpaceSet</code></a>.</li></ul><p><strong>Returns</strong></p><p>A <code>Float64</code> corresponding to the estimated recurrence rate.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>N</code>: Integer defining the microstate size. The default value is <code>3</code>.</li><li><code>threshold</code>: Threshold used to compute the RMA distribution. By default, this is chosen as   the threshold that maximizes the recurrence microstate entropy (RME).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using RecurrenceMicrostatesAnalysis, Distributions
data = StateSpaceSet(rand(Uniform(0, 1), 1000))
rme = measure(RecurrenceRate(), data; N = 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/a48ba3b446fc827628e146e8fd19521c95a2cc3e/src/rqa/rr.jl#L6-L55">source</a></section></details></article><h2 id="Determinism"><a class="docs-heading-anchor" href="#Determinism">Determinism</a><a id="Determinism-1"></a><a class="docs-heading-anchor-permalink" href="#Determinism" title="Permalink"></a></h2><p>In standard RQA, Determinism (DET) measures the fraction of recurrence points forming diagonal line structures (<a href="../../refs/#Webber2015Recurrence">Webber and Marwan, 2015</a>):</p><p class="math-container">\[DET = \frac{\sum_{l=d_{min}}^K l~H_D(l)}{\sum_{i,j=1}^K R_{i,j}},\]</p><p>where <span>$H_D(l)$</span> is the histogram of diagonal line lengths,</p><p class="math-container">\[H_D(l)=\sum_{i,j]1}^K(1-R_{i-1,j-1})(1-R_{i+l,j+l})\prod_{k=0}^{l-1}R_{i+k,j+k}.\]</p><p>The estimation of DET using RMA is based on the work <em>&quot;Density-Based Recurrence Measures from Microstates&quot;</em> (<a href="../../refs/#daCruz2025RQAMeasures">da Cruz <em>et al.</em>, 2025</a>). In that work, the DET expression is rewritten as</p><p class="math-container">\[DET = 1 - \frac{1}{K^2~RR}\sum_{l=1}^{l_{min}-1} l~H_D(l),\]</p><p>and the diagonal histogram <span>$H_D(l)$</span> is related to the RMA distribution through correlations between microstate structures:</p><p class="math-container">\[\frac{H_D(l)}{(K-l-1)^2}=\vec d^{(l)}\cdot\mathcal{R}^{(l+2)}\vec p^{(l+2)}.\]</p><p>For the commonly used case <span>$l_{min} = 2$</span> (currently the only case implemented in the package), this leads to the approximation</p><p class="math-container">\[DET\approx 1 - \frac{\vec d^{(1)}\cdot\mathcal{R}^{(3)}\vec p^{3}}{RR}.\]</p><p>The correlation term <span>$\vec d^{(1)}\cdot\mathcal{R}^{(3)}\vec p^{3}$</span> can be simplified by explicitly identifying the microstates selected by <span>$\vec d^{(1)}$</span>. These correspond to microstates of the form</p><p class="math-container">\[\begin{pmatrix}
\xi &amp; \xi &amp; 0 \\
\xi &amp; 1 &amp; \xi \\
0 &amp; \xi &amp; \xi \\
\end{pmatrix},\]</p><p>where <span>$\xi$</span> denotes an unconstrained entry. There are <span>$64$</span> such microstates among the <span>$512$</span> possible square microstates of size <span>$N = 3$</span>.  Defining the class <span>$C_D$</span> as the set of microstates with this structure, DET can be estimated as:</p><p class="math-container">\[DET\approx 1 - \frac{\sum_{i\in C_D} p_i^{(3)}}{RR},\]</p><p>where <span>$p_i^{(3)}$</span> is the probability of the <span>$i$</span>-th microstate in an RMA distribution of square microstates with size <span>$N = 3$</span>.</p><p>A futher simplification can be obtained by defining <a href="../shapes_and_sampling/#RecurrenceMicrostatesAnalysis.Diagonal"><code>Diagonal</code></a>-shaped microstates (<a href="../../refs/#Ferreira2025RMALib">Ferreira <em>et al.</em>, 2025</a>).  In the structure above, the unconstrained entries <span>$\xi$</span> may represent either recurrences or non-recurrences, leading to the need for all <span>$64$</span> combinations. Diagonal microstates focus directly on the relevant information, namely the diagonal pattern <span>$0~1~0$</span>. In this case, DET can be approximated as</p><p class="math-container">\[DET\approx 1 - \frac{p_3^{(3)}}{RR},\]</p><p>where <span>$p_3^{(3)}$</span> is the probability of observing the diagonal motif <span>$0~1~0$</span>.</p><p>In <strong>RecurrenceMicrostatesAnalysis.jl</strong>, the computation of DET is implemented by the <a href="#Determinism"><code>Determinism</code></a> struct.</p><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis.Determinism"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis.Determinism"><code>RecurrenceMicrostatesAnalysis.Determinism</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Determinism &lt;: QuantificationMeasure</code></pre><p>Define the <em>Determinism</em> (DET) quantification measure.</p><p>DET can be computed either from a distribution of recurrence microstates or directly from time-series data. In both cases, the computation is performed via the <a href="#RecurrenceMicrostatesAnalysis.measure"><code>measure</code></a> function.</p><p><strong>Using a distribution</strong></p><pre><code class="language-julia hljs">measure(::Determinism, dist::Probabilities)</code></pre><p><strong>Arguments</strong></p><ul><li><code>dist</code>: A distribution of recurrence microstates. The distribution must be computed from   <strong>square</strong> or <strong>diagonal</strong> microstates of size 3.</li></ul><p><strong>Returns</strong></p><p>A <code>Float64</code> corresponding to the estimated determinism.</p><p><strong>Examples</strong></p><p><strong>Using square microstates</strong></p><pre><code class="language-julia hljs">using RecurrenceMicrostatesAnalysis, Distributions
data = StateSpaceSet(rand(Uniform(0, 1), 1000))
dist = distribution(data, 0.27, 3)
det = measure(Determinism(), dist)</code></pre><p><strong>Using diagonal microstates</strong></p><pre><code class="language-julia hljs">using RecurrenceMicrostatesAnalysis, Distributions
data = StateSpaceSet(rand(Uniform(0, 1), 1000))
dist = distribution(data, Diagonal(Standard(0.27), 3))
det = measure(Determinism(), dist)</code></pre><p><strong>Using a time series</strong></p><pre><code class="language-julia hljs">measure(::Determinism, [x]; kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>[x]</code>: Time-series data provided as a <a href="../../#StateSpaceSets.StateSpaceSet"><code>StateSpaceSet</code></a>.</li></ul><p><strong>Returns</strong></p><p>A <code>Float64</code> corresponding to the estimated determinism.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>threshold</code>: Threshold used to compute the RMA distribution. By default, this is chosen as   the threshold that maximizes the recurrence microstate entropy (RME).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using RecurrenceMicrostatesAnalysis, Distributions
data = StateSpaceSet(rand(Uniform(0, 1), 1000))
det = measure(Determinism(), data)</code></pre><div class="admonition is-info" id="Note-731bbf05d94063df"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-731bbf05d94063df" title="Permalink"></a></header><div class="admonition-body"><p>When time-series data are provided directly, RecurrenceMicrostatesAnalysis.jl uses <a href="../shapes_and_sampling/#RecurrenceMicrostatesAnalysis.Diagonal"><code>Diagonal</code></a> microstates by default.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/a48ba3b446fc827628e146e8fd19521c95a2cc3e/src/rqa/det.jl#L6-L68">source</a></section></details></article><h2 id="Laminarity"><a class="docs-heading-anchor" href="#Laminarity">Laminarity</a><a id="Laminarity-1"></a><a class="docs-heading-anchor-permalink" href="#Laminarity" title="Permalink"></a></h2><p>Laminarity (LAM) is another classical RQA quantifier that measures the proportion of recurrence points forming vertical (line) structures in a recurrence plot.  It is defined as</p><p class="math-container">\[LAM = \frac{\sum_{l=v_{min}}^K l~H_V(l)}{\sum_{i,j=1}^K R_{i,j}},\]</p><p>where</p><p class="math-container">\[H_V(l)=\sum_{i,j]1}^K(1-R_{i,j-1})(1-R_{i,j+l})\prod_{k=0}^{l-1}R_{i,j+k}.\]</p><p>The estimation of LAM using RMA is also based on the work <em>&quot;Density-Based Recurrence Measures from Microstates&quot;</em> (<a href="../../refs/#daCruz2025RQAMeasures">da Cruz <em>et al.</em>, 2025</a>) and follows the same logical used for determinsm. In this case, the estimation requires microstates of the form</p><p class="math-container">\[\begin{pmatrix}
0 &amp; 1 &amp; 0 \\
\xi &amp; \xi &amp; \xi \\
\xi &amp; \xi &amp; \xi \\
\end{pmatrix},\]</p><p>which defines the class <span>$C_L$</span> of microstates used to estimate LAM as</p><p class="math-container">\[LAM\approx 1 - \frac{\sum_{i\in C_L} p_i^{(3)}}{RR}.\]</p><p>As with determinism, this process can be further simplified by defining a <code>line</code> motif (<a href="../../refs/#Ferreira2025RMALib">Ferreira <em>et al.</em>, 2025</a>), which captures only the relevant information, namely vertical line patterns of the form <span>$0~1~0$</span> in the recurrence plot. In this case, LAM can be approximated as</p><p class="math-container">\[LAM\approx 1 - \frac{p_3^{(3)}}{RR},\]</p><p>where <span>$p_3^{(3)}$</span> denotes the probability of observing the line motif <span>$0~1~0$</span>.</p><p>In <strong>RecurrenceMicrostatesAnalysis.jl</strong>, the computation of LAM is implemented by the <a href="#Laminarity"><code>Laminarity</code></a> struct.</p><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis.Laminarity"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis.Laminarity"><code>RecurrenceMicrostatesAnalysis.Laminarity</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Laminarity &lt;: QuantificationMeasure</code></pre><p>Define the <em>Laminarity</em> (LAM) quantification measure.</p><p>LAM can be computed either from a distribution of recurrence microstates or directly from time-series data. In both cases, the computation is performed via the <a href="#RecurrenceMicrostatesAnalysis.measure"><code>measure</code></a> function.</p><p><strong>Using a distribution</strong></p><pre><code class="language-julia hljs">measure(::Laminarity, dist::Probabilities)</code></pre><p><strong>Arguments</strong></p><ul><li><code>dist</code>: A distribution of recurrence microstates. The distribution must be computed from   <strong>square</strong> or <strong>line</strong> microstates of size 3.</li></ul><p><strong>Returns</strong></p><p>A <code>Float64</code> corresponding to the estimated laminarity.</p><p><strong>Examples</strong></p><p><strong>Using square microstates</strong></p><pre><code class="language-julia hljs">using RecurrenceMicrostatesAnalysis, Distributions
data = StateSpaceSet(rand(Uniform(0, 1), 1000))
dist = distribution(data, 0.27, 3)
lam = measure(Laminarity(), dist)</code></pre><p><strong>Using line microstates:</strong></p><pre><code class="language-julia hljs">using RecurrenceMicrostatesAnalysis, Distributions
data = StateSpaceSet(rand(Uniform(0, 1), 1000))
dist = distribution(data, Rect(Standard(0.27); rows = 1, cols = 3))
lam = measure(Laminarity(), dist)</code></pre><p><strong>Using a time series</strong></p><pre><code class="language-julia hljs">measure(::Laminarity, [x]; kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>[x]</code>: Time-series data provided as a <a href="../../#StateSpaceSets.StateSpaceSet"><code>StateSpaceSet</code></a>.</li></ul><p><strong>Returns</strong></p><p>A <code>Float64</code> corresponding to the estimated laminarity.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>threshold</code>: Threshold used to compute the RMA distribution. By default, this is chosen as   the threshold that maximizes the recurrence microstate entropy (RME).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using RecurrenceMicrostatesAnalysis, Distributions
data = StateSpaceSet(rand(Uniform(0, 1), 1000))
lam = measure(Laminarity(), data)</code></pre><div class="admonition is-info" id="Note-6d49880ce62cdad4"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-6d49880ce62cdad4" title="Permalink"></a></header><div class="admonition-body"><p>When time-series data are provided directly, RecurrenceMicrostatesAnalysis.jl uses line microstates by default.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/a48ba3b446fc827628e146e8fd19521c95a2cc3e/src/rqa/lam.jl#L6-L69">source</a></section></details></article><h2 id="Disorder"><a class="docs-heading-anchor" href="#Disorder">Disorder</a><a id="Disorder-1"></a><a class="docs-heading-anchor-permalink" href="#Disorder" title="Permalink"></a></h2><p>The disorder quantifier is implemented based on the work <em>“Quantifying Disorder in Data”</em> (<a href="../../refs/#Flauzino2025Disorder">Flauzino <em>et al.</em>, 2025</a>).  It is a novel and powerful tool for data analysis, allowing the distinction between stochastic and deterministic time series, as well as between different types of stochastic dynamics, such as white, pink, and red Gaussian noise.</p><p>Disorder is implemented using square recurrence microstates, which can be permuted by rows and columns and transposed (see <a href="../utils/#Permutations-and-Transposition">Permutations and Transposition</a>).  This procedure generates a set of equivalent microstates given by</p><p class="math-container">\[\mathcal{M}_a(\mathbf{M}) = \bigcup_{\sigma_i,\sigma_j\in S_N}\{\mathcal{L}_{\sigma_j}\mathcal{T}\mathcal{L}_{\sigma_i}\mathbf{M},\quad\mathcal{T}\mathcal{L}_{\sigma_j}\mathcal{T}\mathcal{L}_{\sigma_i}\mathbf{M}\}.\]</p><p>This defines an equivalence class of microstates denoted by <span>$\mathcal{M}_a$</span>.</p><p>The probability of observing a given microstate <span>$\mathbf M^{i,(N)}$</span> in the recurrence plot, denoted by <span>$p_i^{(N)}$</span>, is computed using <strong>RecurrenceMicrostatesAnalysis.jl</strong>. To compute disorder, the probabilities of microstates belonging to the same class must be normalized. Thus, for <span>$\mathbf M^{i, (N)} \in \mathcal{M}_a$</span>, the normalized probability within the class is defined as</p><p class="math-container">\[p_i^{(a, N)} = \frac{p_i^{(N)}}{\sum_{\mathbf{M}_j^{(N)} \in \mathcal{M}_a}~p_j^{(N)}}.\]</p><p>The information entropy associated with the probability distribution of microstates in the class <span>$\mathcal{M}_a$</span> is then defined as</p><p class="math-container">\[\xi_a(\varepsilon) \stackrel{\mathrm{def}}{=} -\sum_{\mathbf{M}_i^{(N)} \in \mathcal{M}_a} p_i^{(a, N)} \ln p_i^{(a, N)}.\]</p><p>This entropy is normalized by <span>$\ln m_a$</span>, where <span>$m_a$</span> is the number of microstates in the class <span>$\mathcal{M}_a$</span>. Using <strong>RecurrenceMicrostatesAnalysis.jl</strong>, the normalized quantity <span>$\xi_a(\varepsilon) / \ln m_a$</span> can be computed as</p><pre><code class="language-julia hljs">using Distributions, RecurrenceMicrostatesAnalysis
data = StateSpaceSet(rand(Uniform(0, 1), 1000))
dist = distribution(data, 0.27, 4; sampling = Full())

class = 102
measure(Disorder(4), class, dist)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.9811412516811912</code></pre><p>The total entropy over all classes for a given threshold <span>$\varepsilon$</span> is defined as</p><p class="math-container">\[\xi(\varepsilon) \stackrel{\mathrm{def}}{=} \frac{1}{A} \sum_{a = 1}^A \frac{\xi_a(\varepsilon)}{\ln m_a},\]</p><p>where <span>$A$</span> is the number of contributing classes and defines the maximum possible amplitude. This normalization factor can also be computed using <strong>RecurrenceMicrostatesAnalysis.jl</strong>:</p><pre><code class="language-julia hljs">A = RecurrenceMicrostatesAnalysis.get_disorder_norm_factor(Disorder(4), data)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">145</code></pre><p>And the total entropy:</p><pre><code class="language-julia hljs">measure(Disorder(4), dist, A)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.9618742262053327</code></pre><p>Finally, the the <em>disorder index via symmetry in recurrence microstates</em> (DISREM), or simply <strong>disorder</strong>, is defined as</p><p class="math-container">\[\Xi = \max_{\varepsilon} \xi(\varepsilon).\]</p><p>In <strong>RecurrenceMicrostatesAnalysis.jl</strong>, this quantifier is implemented by the <a href="#Disorder"><code>Disorder</code></a> struct.</p><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis.Disorder"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis.Disorder"><code>RecurrenceMicrostatesAnalysis.Disorder</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Disorder{N} &lt;: QuantificationMeasure</code></pre><p>Define the <em>Disorder</em> quantification measure for microstates of size <code>N</code> (<a href="../../refs/#Flauzino2025Disorder">Flauzino <em>et al.</em>, 2025</a>).</p><p>The <code>Disorder</code> struct stores a set of <code>labels</code> that identify the microstates belonging to each equivalence class <span>$\mathcal{M}_a$</span>.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">Disorder(N)</code></pre><p>Here, <span>$N$</span> must be equal to 2, 3, 4, or 5. Computing disorder for larger values of <span>$N$</span> is currently not supported, as it would require a prohibitive amount of memory with the current implementation.</p><p>The computation of <em>Disorder</em> is performed via the <a href="#RecurrenceMicrostatesAnalysis.measure"><code>measure</code></a> function:</p><pre><code class="language-julia hljs">measure(settings::Disorder{N}, [x]; kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>[x]</code>: Time-series data provided as a <a href="../../#StateSpaceSets.StateSpaceSet"><code>StateSpaceSet</code></a>.</li></ul><p><strong>Returns</strong></p><p>A <code>Float64</code> corresponding to the disorder value (<span>$\Xi$</span>).</p><p><strong>Keyword Arguments</strong></p><ul><li><code>th</code>: Reference threshold used to maximize disorder. To improve computational performance,   this value limits the search range of thresholds. By default, it is set to the threshold   that maximizes disorder for a sampling rate of <span>$5%$</span>.</li><li><code>th_min</code>: Minimum threshold defining the search range. By default, this is set to <code>0.85 * th</code>.</li><li><code>th_max</code>: Maximum threshold defining the search range. By default, this is set to <code>1.25 * th</code>.</li><li><code>num_tests</code>: Number of threshold values evaluated within the specified range. The default value is <code>40</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using RecurrenceMicrostatesAnalysis, Distributions
data = StateSpaceSet(rand(Uniform(0, 1), 1000))
disrem = measure(Disorder(4), data)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/a48ba3b446fc827628e146e8fd19521c95a2cc3e/src/rqa/disorder.jl#L6-L47">source</a></section></details></article><h3 id="Computing-disorder-for-compatible-time-series"><a class="docs-heading-anchor" href="#Computing-disorder-for-compatible-time-series">Computing disorder for compatible time series</a><a id="Computing-disorder-for-compatible-time-series-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-disorder-for-compatible-time-series" title="Permalink"></a></h3><p>Consider a scenario in which a long time series is split into multiple windows. <strong>RecurrenceMicrostatesAnalysis.jl</strong> provides a compact interface to compute the disorder for each window.</p><p>As an example, consider a time series with 50,000 points consisting of a sine wave with added white noise, alternating every five windows:</p><pre><code class="language-julia hljs">function data_gen(t)
    x = sin.(6*π .* t)

    count = 0
    for i in 1:1000:50_000
        if count &lt; 5
            x[i:(i-1)+1000] .+= rand(Normal(0, 0.25), 1000)
        elseif count ≥ 9
            count = -1
        end

        count += 1
    end

    return x
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">data_gen (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">using CairoMakie

t = range(0, 50, 50_000)
data = data_gen(t)

lines(t, data)</code></pre><img src="9df34659.png" alt="Example block output"/><p>The disorder can be computed using the following method:</p><pre><code class="language-julia hljs">measure(settings::Disorder{N}, dataset::Vector{StateSpaceSet}, th_min::Float64, th_max::Float64)</code></pre><p>To apply it, the time series must first be split into a vector of <a href="../../#StateSpaceSets.StateSpaceSet"><code>StateSpaceSet</code></a> objects:</p><pre><code class="language-julia hljs">windows = [ data[(i + 1):(i + 1000)] for i in 0:1000:(length(data) - 1000)]
dataset = Vector{StateSpaceSet}(undef, length(windows))
for i ∈ eachindex(windows)
    dataset[i] = StateSpaceSet(windows[i])
end

dataset</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">50-element Vector{StateSpaceSet}:
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 ⋮
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points</code></pre><p>Next, the threshold range <code>th_min</code> and <code>th_max</code> must be defined. There are two possible approaches:</p><ol><li><p>Use the full range of admissible threshold values by setting <code>th_min = 0</code> and <code>th_max = maximum(pairwise(Euclidean(), data, data))</code>, and choosing a small step size via the <code>num_tests</code> keywork argument (e.g., <code>num_tests = 1000</code>). This approach yields the global maximum disorder values but can be computationally expensive.</p></li><li><p>Use a small interval centered around a known threshold value. This is the recommended approach and is adopted here.</p></li></ol><p>To obtain a suitable reference threshold, we select a subset of windows and compute the optimal disorder threshold using the <a href="../utils/#RecurrenceMicrostatesAnalysis.optimize"><code>optimize</code></a> function:</p><pre><code class="language-julia hljs">using Statistics

function find_threshold(disorder, data)
    ths = zeros(Float64, 10)
    for i ∈ eachindex(ths)
        idx = rand(1:length(windows))
        ths[i] = optimize(Threshold(), disorder, data[idx])[1]
    end

    μ = mean(ths)
    σ = std(ths)

    return (max(0.0, μ - 1.5 * σ), μ + 1.5 * σ)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">find_threshold (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">dis = Disorder(4)
th_min, th_max = find_threshold(dis, dataset)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.056541722911837566, 0.5963644620249501)</code></pre><p>Finally, the disorder can be computed for all windows using the <a href="#RecurrenceMicrostatesAnalysis.measure"><code>measure</code></a> function:</p><pre><code class="language-julia hljs">results = measure(dis, dataset, th_min, th_max)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">50-element Vector{Float32}:
 0.957537
 0.9498441
 0.9545279
 0.9532753
 0.9567204
 0.081657924
 0.08164975
 0.0816446
 0.08169388
 0.08165888
 ⋮
 0.95485777
 0.955812
 0.9541346
 0.95128554
 0.08163094
 0.08250993
 0.08239036
 0.08188252
 0.08170029</code></pre><pre><code class="language-julia hljs">scatterlines(results)</code></pre><img src="5871100f.png" alt="Example block output"/><div class="admonition is-info" id="Info-249c0128699f130c"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-249c0128699f130c" title="Permalink"></a></header><div class="admonition-body"><p>When computing Disorder for compatible time series, the same threshold range is used for all windows.  However, the disorder value of each window corresponds to the maximum over that range, and therefore the optimal threshold may differ between windows.</p></div></div><div class="admonition is-success" id="Tip-325cc7a89d7e0d71"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-325cc7a89d7e0d71" title="Permalink"></a></header><div class="admonition-body"><p>Disorder can also be computed using the <a href="../gpu/#GPU"><code>GPU</code></a> backend:</p><pre><code class="language-julia hljs">measure(settings::Disorder{N}, dataset::Vector{&lt;:AbstractGPUVector{SVector{D, Float32}}}, th_min::Float32, th_max::Float32)</code></pre><p>The procedure is identical, but each window must first be transferred to the GPU:</p><pre><code class="language-julia hljs">for i ∈ eachindex(windows)
    dataset[i] = StateSpaceSet(Float32.(windows[i])) |&gt; CuVector
end</code></pre></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../distributions/">« Distributions</a><a class="docs-footer-nextpage" href="../recurrences/">Recurrence Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 12 January 2026 20:10">Monday 12 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
