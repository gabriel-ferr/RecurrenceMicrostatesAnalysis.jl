<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quantifiers · RecurrenceMicrostatesAnalysis.jl</title><meta name="title" content="Quantifiers · RecurrenceMicrostatesAnalysis.jl"/><meta property="og:title" content="Quantifiers · RecurrenceMicrostatesAnalysis.jl"/><meta property="twitter:title" content="Quantifiers · RecurrenceMicrostatesAnalysis.jl"/><meta name="description" content="Documentation for RecurrenceMicrostatesAnalysis.jl."/><meta property="og:description" content="Documentation for RecurrenceMicrostatesAnalysis.jl."/><meta property="twitter:description" content="Documentation for RecurrenceMicrostatesAnalysis.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">RecurrenceMicrostatesAnalysis.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../distributions/">Distributions</a></li><li class="is-active"><a class="tocitem" href>Quantifiers</a><ul class="internal"><li><a class="tocitem" href="#Recurrence-microstates-entropy"><span>Recurrence microstates entropy</span></a></li><li><a class="tocitem" href="#Recurrence-rate"><span>Recurrence rate</span></a></li><li><a class="tocitem" href="#Determinism"><span>Determinism</span></a></li><li><a class="tocitem" href="#Laminarity"><span>Laminarity</span></a></li><li><a class="tocitem" href="#Disorder"><span>Disorder</span></a></li></ul></li><li><a class="tocitem" href="../operations/">Operations</a></li><li><a class="tocitem" href="../recurrences/">Recurrence Functions</a></li><li><a class="tocitem" href="../shapes_and_sampling/">Shapes and Sampling</a></li><li><a class="tocitem" href="../gpu/">GPU</a></li><li><a class="tocitem" href="../tips/">Performance Tips</a></li><li><a class="tocitem" href="../utils/">Utils</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/ml/">Machine Learning</a></li></ul></li><li><a class="tocitem" href="../../dev/">Developers</a></li><li><a class="tocitem" href="../../refs/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li class="is-active"><a href>Quantifiers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quantifiers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/main/docs/src/tutorial/quantifiers.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Quantifiers"><a class="docs-heading-anchor" href="#Quantifiers">Quantifiers</a><a id="Quantifiers-1"></a><a class="docs-heading-anchor-permalink" href="#Quantifiers" title="Permalink"></a></h1><p>Quantifiers are measures used to characterize specific properties of a system.  Currently, RMA provides five quantifiers that can be computed or estimated from a microstate distribution.  Three of them are estimations of classical Recurrence Quantification Analysis (RQA) measures: <strong>recurrence rate</strong>, <strong>determinism</strong>, and <strong>laminarity</strong>.  One corresponds to an information-theoretic entropy.  And, the final quantifier is the <strong>disorder</strong> measure, which is defined using the microstate distribution as the basis for applying the method.</p><p>In this section, we describe each of these quantifiers and explain how to compute them using the RecurrenceMicrostatesAnalysis.jl package.</p><p>All quantifiers implemented in the package inherit from <a href="#RecurrenceMicrostatesAnalysis.QuantificationMeasure"><code>QuantificationMeasure</code></a>, and their computation is performed using the <a href="#RecurrenceMicrostatesAnalysis.measure"><code>measure</code></a> function.</p><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis.QuantificationMeasure"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis.QuantificationMeasure"><code>RecurrenceMicrostatesAnalysis.QuantificationMeasure</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">QuantificationMeasure</code></pre><p>Abstract supertype defining an RQA or RMA quantification measure.   All quantifiers implemented in the package inherit from this type and define their computation through the <a href="#RecurrenceMicrostatesAnalysis.measure"><code>measure</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/acaff7c874cf44650b7bd32f7da79eab9cd6199b/src/core/measures.jl#L6-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis.measure"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis.measure"><code>RecurrenceMicrostatesAnalysis.measure</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">measure(qm::QuantificationMeasure, [...])</code></pre><p>Compute the quantifier defined by the given <a href="#RecurrenceMicrostatesAnalysis.QuantificationMeasure"><code>QuantificationMeasure</code></a> instance.   Each implementation may accept different parameters (<code>[...]</code>), depending on the specific quantifier.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/acaff7c874cf44650b7bd32f7da79eab9cd6199b/src/core/measures.jl#L17-L22">source</a></section></details></article><h2 id="Recurrence-microstates-entropy"><a class="docs-heading-anchor" href="#Recurrence-microstates-entropy">Recurrence microstates entropy</a><a id="Recurrence-microstates-entropy-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrence-microstates-entropy" title="Permalink"></a></h2><p>The recurrence microstates entropy (RME) was introduced in 2018 and marks the beginning of the RMA framework (<a href="../../refs/#Corso2018Entropy">Corso <em>et al.</em>, 2018</a>). It is defined as the Shannon entropy of the RMA distribution:</p><p class="math-container">\[RME = -\sum_{i = 1}^{2^\sigma} p_i^{(n)} \ln p_i^{(n)},\]</p><p>where <span>$n$</span> is the microstate length, <span>$\sigma$</span> is the number of recurrence elements constrained within microstate (e.g., <span>$\sigma = n^2$</span> for square microstates), and <span>$p_i^{(n)}$</span> denotes the probability of the microstate with decimal representation <span>$i$</span> in the distribution.</p><p>In RecurrenceMicrostatesAnalysis.jl, the RME is implemented by the <a href="#RecurrenceMicrostatesAnalysis.RecurrenceEntropy"><code>RecurrenceEntropy</code></a> struct.</p><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis.RecurrenceEntropy"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis.RecurrenceEntropy"><code>RecurrenceMicrostatesAnalysis.RecurrenceEntropy</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RecurrenceEntropy &lt;: QuantificationMeasure</code></pre><p>Defines the <em>Recurrence Microstates Entropy</em> (RME) quantification measure.</p><p>The computation of RME is performed using the <a href="#RecurrenceMicrostatesAnalysis.measure"><code>measure</code></a> function, for which two implementations are provided.</p><p><strong>Using a distribution</strong></p><pre><code class="language-julia hljs">measure(::RecurrenceEntropy, dist::Probabilities)</code></pre><p><strong>Input</strong></p><ul><li>The <code>QuantificationMeasure</code>.</li><li><code>dist</code>: a distribution of recurrence microstates.</li></ul><p><strong>Output</strong></p><p>Returns a <code>Float64</code> corresponding to the RME computed using the Shannon entropy.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using RecurrenceMicrostatesAnalysis, Distributions
data = StateSpaceSet(rand(Uniform(0, 1), 1000))
dist = distribution(data, 0.27, 3)
rme = measure(RecurrenceEntropy(), dist)</code></pre><p><strong>Using a time series</strong></p><pre><code class="language-julia hljs">measure(::RecurrenceEntropy, [x]; kwargs...)</code></pre><p><strong>Input</strong></p><ul><li>The <code>QuantificationMeasure</code>.</li><li><code>[x]</code>: time-series provided as an <a href="../../#StateSpaceSets.StateSpaceSet"><code>StateSpaceSet</code></a>.</li></ul><p><strong>Output</strong></p><p>Returns a <code>Float64</code> corresponding to the <strong>maximum</strong> RME based on the Shannon Entropy.</p><p><strong>Keyword arguments</strong></p><ul><li><code>n</code>: an <code>Integer</code> defining the microstates size. The default value is <code>3</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using RecurrenceMicrostatesAnalysis, Distributions
data = StateSpaceSet(rand(Uniform(0, 1), 1000))
rme = measure(RecurrenceEntropy(), data; n = 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/acaff7c874cf44650b7bd32f7da79eab9cd6199b/src/rqa/entropy.jl#L6-L52">source</a></section></details></article><p>Since the output of the <a href="../distributions/#RecurrenceMicrostatesAnalysis.distribution"><code>distribution</code></a> function is a <a href="../../#ComplexityMeasures.Probabilities"><code>Probabilities</code></a> object, the package also supports other information or complexity measures, provided by the package <a href="https://juliadynamics.github.io/DynamicalSystemsDocs.jl/complexitymeasures/stable/">ComplexityMeasures.jl</a>.</p><h2 id="Recurrence-rate"><a class="docs-heading-anchor" href="#Recurrence-rate">Recurrence rate</a><a id="Recurrence-rate-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrence-rate" title="Permalink"></a></h2><p>The recurrence rate quantifies the proportion of black points in a recurrence plot, serving as a measure of the relative density of recurrence points in the sparse recurrence matrix (<a href="../../refs/#Webber2015Recurrence">Webber and Marwan, 2015</a>). In standard RQA, it is defined as</p><p class="math-container">\[RR = \frac{1}{K^2} \sum_{i,j=1}^K R_{i,j}.\]</p><p>When estimated using RMA, the recurrence rate is defined as the expected value of the recurrence rate over the microstate distribution:</p><p class="math-container">\[RR = \sum_{i = 1}^{2^\sigma} p_i^{(n)} RR_i^{(n)},\]</p><p>where <span>$RR_i^{(n)}$</span> denotes the recurrence rate of the <span>$i$</span>-th microstate. For square microstates, this quantity is given by</p><p class="math-container">\[RR_i^{(n)} = \frac{1}{\sigma} \sum_{m,n=1}^n M_{m,n}^{i, (n)},\]</p><p>where <span>$\mathbf M_i^{(n)}$</span> represents the structure of the microstate identified by the decimal index <span>$i$</span>, with size <span>$n$</span>, for a given motif shape (in this case, square).</p><p>In RecurrenceMicrostatesAnalysis.jl, this quantifier is implemented by the <a href="#RecurrenceMicrostatesAnalysis.RecurrenceRate"><code>RecurrenceRate</code></a> struct.</p><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis.RecurrenceRate"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis.RecurrenceRate"><code>RecurrenceMicrostatesAnalysis.RecurrenceRate</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RecurrenceRate &lt;: QuantificationMeasure</code></pre><p>Defines the <em>Recurrence Rate</em> (RR) quantification measure.  The computation of RR is performed using the <a href="#RecurrenceMicrostatesAnalysis.measure"><code>measure</code></a> function, for which two implementations are provided.</p><p><strong>Using a distribution</strong></p><pre><code class="language-julia hljs">measure(::RecurrenceRate, dist::Probabilities)</code></pre><p><strong>Input</strong></p><ul><li>The <code>QuantificationMeasure</code>.</li><li><code>dist</code>: a distribution of recurrence microstates.</li></ul><p><strong>Output</strong></p><p>Returns a <code>Float64</code> corresponding to the estimated Recurrence Rate.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using RecurrenceMicrostatesAnalysis, Distributions
data = StateSpaceSet(rand(Uniform(0, 1), 1000))
dist = distribution(data, 0.27, 3)
rr = measure(RecurrenceRate(), dist)</code></pre><p><strong>Using a time series</strong></p><pre><code class="language-julia hljs">measure(::RecurrenceRate, [x]; kwargs...)</code></pre><p><strong>Input</strong></p><ul><li>The <code>QuantificationMeasure</code>.</li><li><code>[x]</code>: time-series data provided as a <a href="../../#StateSpaceSets.StateSpaceSet"><code>StateSpaceSet</code></a>.</li></ul><p><strong>Output</strong></p><p>Returns a <code>Float64</code> corresponding to the estimated Recurrence Rate.</p><p><strong>Keyword arguments</strong></p><ul><li><code>n</code>: an <code>Integer</code> which defines the microstates size. The default value is <code>3</code>.</li><li><code>threshold</code>: threshold used to compute the RMA distribution. By default, this is the <code>threshold</code> that maximizes the RME.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using RecurrenceMicrostatesAnalysis, Distributions
data = StateSpaceSet(rand(Uniform(0, 1), 1000))
rme = measure(RecurrenceRate(), data; n = 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/acaff7c874cf44650b7bd32f7da79eab9cd6199b/src/rqa/rr.jl#L6-L53">source</a></section></details></article><h2 id="Determinism"><a class="docs-heading-anchor" href="#Determinism">Determinism</a><a id="Determinism-1"></a><a class="docs-heading-anchor-permalink" href="#Determinism" title="Permalink"></a></h2><p>In standard RQA, determinism (DET) is defined as the fraction of recurrence points that form diagonal line structures in the recurrence plot (<a href="../../refs/#Webber2015Recurrence">Webber and Marwan, 2015</a>):</p><p class="math-container">\[DET = \frac{\sum_{l=d_{min}}^K l~H_D(l)}{\sum_{i,j=1}^N R_{i,j}},\]</p><p>where <span>$H_D(l)$</span> denotes the histogram of diagonal line lengths in the RP, given by</p><p class="math-container">\[H_D(l)=\sum_{i,j]1}^N(1-R_{i-1,j-1})(1-R_{i+l,j+l})\prod_{k=0}^{l-1}R_{i+k,j+k}.\]</p><p>The estimation of DET using RMA is based on the work <em>&quot;Density-Based Recurrence Measures from Microstates&quot;</em> (<a href="../../refs/#daCruz2025RQAMeasures">da Cruz <em>et al.</em>, 2025</a>). In that work, the DET expression is rewritten as</p><p class="math-container">\[DET = 1 - \frac{1}{N^2~RR}\sum_{l=1}^{l_{min}-1} l~H_D(l),\]</p><p>and the diagonal histogram <span>$H_D(l)$</span> is related to the RMA distribution through correlations between microstate structures:</p><p class="math-container">\[\frac{H_D(l)}{(N-l-1)^2}=\vec d^{(l)}\cdot\mathcal{R}^{(l+2)}\vec p^{(l+2)}.\]</p><p>For the commonly used case <span>$l_{min} = 2$</span> (currently the only case implemented in the package), this leads to the approximation</p><p class="math-container">\[DET\approx 1 - \frac{\vec d^{(1)}\cdot\mathcal{R}^{(3)}\vec p^{3}}{RR}.\]</p><p>The correlation term <span>$\vec d^{(1)}\cdot\mathcal{R}^{(3)}\vec p^{3}$</span> can be simplified by explicitly identifying the microstates selected by <span>$\vec d^{(1)}$</span>. These correspond to microstates of the form</p><p class="math-container">\[\begin{pmatrix}
\xi &amp; \xi &amp; 0 \\
\xi &amp; 1 &amp; \xi \\
0 &amp; \xi &amp; \xi \\
\end{pmatrix},\]</p><p>where <span>$\xi$</span> denotes an unconstrained entry. There are <span>$64$</span> such microstates among the <span>$512$</span> possible square microstates of size <span>$n = 3$</span>.  Defining the class <span>$C_D$</span> as the set of microstates with this structure, DET can be estimated as:</p><p class="math-container">\[DET\approx 1 - \frac{\sum_{i\in C_D} p_i^{(3)}}{RR},\]</p><p>where <span>$p_i^{(3)}$</span> is the probability of the <span>$i$</span>-th microstate in an RMA distribution of square microstates with size <span>$n = 3$</span>.</p><p>A futher simplification can be obtained by defining <a href="../shapes_and_sampling/#RecurrenceMicrostatesAnalysis.Diagonal"><code>Diagonal</code></a>-shaped microstates (<a href="../../refs/#Ferreira2025RMALib">Ferreira <em>et al.</em>, 2025</a>).  In the structure above, the unconstrained entries <span>$\xi$</span> may represent either recurrences or non-recurrences, leading to the need for all <span>$64$</span> combinations. Diagonal microstates focus directly on the relevant information, namely the diagonal pattern <span>$0~1~0$</span>. In this case, DET can be approximated as</p><p class="math-container">\[DET\approx 1 - \frac{p_3^{(3)}}{RR},\]</p><p>where <span>$p_3^{(3)}$</span> is the probability of observing the diagonal motif <span>$0~1~0$</span>.</p><p>In RecurrenceMicrostatesAnalysis.jl, the computation of DET is implemented by the <a href="#Determinism"><code>Determinism</code></a> struct.</p><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis.Determinism"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis.Determinism"><code>RecurrenceMicrostatesAnalysis.Determinism</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Determinism &lt;: QuantificationMeasure</code></pre><p>Defines the <em>Determinism</em> (DET) quantification measure.  The computation of DET is performed using the <a href="#RecurrenceMicrostatesAnalysis.measure"><code>measure</code></a> function, for which two implementations are provided.</p><p><strong>Using a distribution</strong></p><pre><code class="language-julia hljs">measure(::Determinism, dist::Probabilities)</code></pre><p><strong>Input</strong></p><ul><li>The <code>QuantificationMeasure</code>.</li><li><code>dist</code>: a distribution of recurrence microstates. The distribution must be computed from <strong>square</strong> or <strong>diagonal</strong> microstates with size 3.</li></ul><p><strong>Output</strong></p><p>Returns a <code>Float64</code> corresponding to the estimated determinism.</p><p><strong>Examples</strong></p><ul><li>Using <strong>square</strong> microstates:</li></ul><pre><code class="language-julia hljs">using RecurrenceMicrostatesAnalysis, Distributions
data = StateSpaceSet(rand(Uniform(0, 1), 1000))
dist = distribution(data, 0.27, 3)
det = measure(Determinism(), dist)</code></pre><ul><li>Using <strong>diagonal</strong> microstates:</li></ul><pre><code class="language-julia hljs">using RecurrenceMicrostatesAnalysis, Distributions
data = StateSpaceSet(rand(Uniform(0, 1), 1000))
dist = distribution(data, Diagonal(Standard(0.27), 3))
det = measure(Determinism(), dist)</code></pre><p><strong>Using a time series</strong></p><pre><code class="language-julia hljs">measure(::Determinism, [x]; kwargs...)</code></pre><p><strong>Input</strong></p><ul><li>The <code>QuantificationMeasure</code>.</li><li><code>[x]</code>: time-series data provided as a <a href="../../#StateSpaceSets.StateSpaceSet"><code>StateSpaceSet</code></a>.</li></ul><p><strong>Output</strong></p><p>Returns a <code>Float64</code> corresponding to the estimated determinism.</p><p><strong>Keyword arguments</strong></p><ul><li><code>threshold</code>: threshold used to compute the RMA distribution. By default, this is the threshold that maximizes the RME.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using RecurrenceMicrostatesAnalysis, Distributions
data = StateSpaceSet(rand(Uniform(0, 1), 1000))
det = measure(Determinism(), data)</code></pre><div class="admonition is-info" id="Note-11cf8fe3c205a33e"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-11cf8fe3c205a33e" title="Permalink"></a></header><div class="admonition-body"><p>When a time series is provided as input, RecurrenceMicrostatesAnalysis.jl uses <a href="../shapes_and_sampling/#RecurrenceMicrostatesAnalysis.Diagonal"><code>Diagonal</code></a> microstates by default.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/acaff7c874cf44650b7bd32f7da79eab9cd6199b/src/rqa/det.jl#L6-L65">source</a></section></details></article><h2 id="Laminarity"><a class="docs-heading-anchor" href="#Laminarity">Laminarity</a><a id="Laminarity-1"></a><a class="docs-heading-anchor-permalink" href="#Laminarity" title="Permalink"></a></h2><p>Laminarity (LAM) is another classical RQA quantifier that measures the proportion of recurrence points forming vertical (line) structures in a recurrence plot.  It is defined as</p><p class="math-container">\[LAM = \frac{\sum_{l=v_{min}}^K l~H_V(l)}{\sum_{i,j=1}^N R_{i,j}},\]</p><p>where</p><p class="math-container">\[H_V(l)=\sum_{i,j]1}^N(1-R_{i,j-1})(1-R_{i,j+l})\prod_{k=0}^{l-1}R_{i,j+k}.\]</p><p>The estimation of LAM using RMA is also based on the work <em>&quot;Density-Based Recurrence Measures from Microstates&quot;</em> (<a href="../../refs/#daCruz2025RQAMeasures">da Cruz <em>et al.</em>, 2025</a>) and follows the same logical used for determinsm. In this case, the estimation requires microstates of the form</p><p class="math-container">\[\begin{pmatrix}
0 &amp; 1 &amp; 0 \\
\xi &amp; \xi &amp; \xi \\
\xi &amp; \xi &amp; \xi \\
\end{pmatrix},\]</p><p>which defines the class <span>$C_L$</span> of microstates used to estimate LAM as</p><p class="math-container">\[LAM\approx 1 - \frac{\sum_{i\in C_L} p_i^{(3)}}{RR}.\]</p><p>As with determinism, this process can be further simplified by defining a <code>line</code> motif (<a href="../../refs/#Ferreira2025RMALib">Ferreira <em>et al.</em>, 2025</a>), which captures only the relevant information, namely vertical line patterns of the form <span>$0~1~0$</span> in the recurrence plot. In this case, LAM can be approximated as</p><p class="math-container">\[LAM\approx 1 - \frac{p_3^{(3)}}{RR},\]</p><p>where <span>$p_3^{(3)}$</span> denotes the probability of observing the line motif <span>$0~1~0$</span>.</p><p>In RecurrenceMicrostatesAnalysis.jl, the computation of LAM is implemented by the <a href="#Laminarity"><code>Laminarity</code></a> struct.</p><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis.Laminarity"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis.Laminarity"><code>RecurrenceMicrostatesAnalysis.Laminarity</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Laminarity &lt;: QuantificationMeasure</code></pre><p>Defines the <em>Laminarity</em> (LAM) quantification measure. The computation of LAM is performed using the <a href="#RecurrenceMicrostatesAnalysis.measure"><code>measure</code></a> function, for which two implementations are provided.</p><p><strong>Using a distribution</strong></p><pre><code class="language-julia hljs">measure(::Laminarity, dist::Probabilities)</code></pre><p><strong>Input</strong></p><ul><li>The <code>QuantificationMeasure</code>.</li><li><code>dist</code>: a distribution of recurrence microstates. The distribution must be computed from square or line microstates with size 3.</li></ul><p><strong>Output</strong></p><p>Returns a <code>Float64</code> corresponding to the estimated laminarity.</p><p><strong>Examples</strong></p><ul><li>Using <strong>square</strong> microstates:</li></ul><pre><code class="language-julia hljs">using RecurrenceMicrostatesAnalysis, Distributions
data = StateSpaceSet(rand(Uniform(0, 1), 1000))
dist = distribution(data, 0.27, 3)
lam = measure(Laminarity(), dist)</code></pre><ul><li>Using <strong>line</strong> microstates:</li></ul><pre><code class="language-julia hljs">using RecurrenceMicrostatesAnalysis, Distributions
data = StateSpaceSet(rand(Uniform(0, 1), 1000))
dist = distribution(data, Rect(Standard(0.27); rows = 1, cols = 3))
lam = measure(Laminarity(), dist)</code></pre><p><strong>Using a time series</strong></p><pre><code class="language-julia hljs">measure(::Laminarity, [x]; kwargs...)</code></pre><p><strong>Input</strong></p><ul><li>The <code>QuantificationMeasure</code>.</li><li><code>[x]</code>: time-series data provided as a <a href="../../#StateSpaceSets.StateSpaceSet"><code>StateSpaceSet</code></a>.</li></ul><p><strong>Output</strong></p><p>Returns a <code>Float64</code> corresponding to the estimated laminarity.</p><p><strong>Keyword arguments</strong></p><ul><li><code>threshold</code>: threshold used to compute the RMA distribution. By default, this is the threshold that maximizes the RME.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using RecurrenceMicrostatesAnalysis, Distributions
data = StateSpaceSet(rand(Uniform(0, 1), 1000))
lam = measure(Laminarity(), data)</code></pre><div class="admonition is-info" id="Note-a34acf61c563d4d2"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-a34acf61c563d4d2" title="Permalink"></a></header><div class="admonition-body"><p>When a time series is provided as input, RecurrenceMicrostatesAnalysis.jl uses <code>line</code> microstates by default.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/acaff7c874cf44650b7bd32f7da79eab9cd6199b/src/rqa/lam.jl#L6-L65">source</a></section></details></article><h2 id="Disorder"><a class="docs-heading-anchor" href="#Disorder">Disorder</a><a id="Disorder-1"></a><a class="docs-heading-anchor-permalink" href="#Disorder" title="Permalink"></a></h2><p>The disorder quantifier is implemented based on the work <em>“Quantifying Disorder in Data”</em> (<a href="../../refs/#Flauzino2025Disorder">Flauzino <em>et al.</em>, 2025</a>).  It is a novel and powerful tool for data analysis, allowing the differentiation between stochastic and deterministic time series, as well as between different types of stochastic dynamics, such as white, pink, and red Gaussian noise.</p><p>Disorder is implemented using square recurrence microstates, which can be permuted by rows and columns and transposed (see <a href="../operations/#Permutations-and-Transposition">Permutations and Transposition</a>).  This procedure generates a set of equivalent microstates given by</p><p class="math-container">\[\mathcal{M}_a(\mathbf{M}) = \bigcup_{\sigma_i,\sigma_j\in S_N}\{\mathcal{L}_{\sigma_j}\mathcal{T}\mathcal{L}_{\sigma_i}\mathbf{M},\quad\mathcal{T}\mathcal{L}_{\sigma_j}\mathcal{T}\mathcal{L}_{\sigma_i}\mathbf{M}\}.\]</p><p>This defines an equivalence class of microstates denoted by <span>$\mathcal{M}_a$</span>.</p><p>The probability of observing a given microstate <span>$\mathbf M_i^{(n)}$</span> in the recurrence plot, denoted by <span>$p_i^{(n)}$</span>, is computed using RecurrenceMicrostatesAnalysis.jl. To compute disorder, the probabilities of microstates belonging to the same class must be normalized. Thus, for <span>$\mathbf M_i^{(n)} \in \mathcal{M}_a$</span>, the normalized probability within the class is defined as</p><p class="math-container">\[p_i^{(a, n)} = \frac{p_i^{(n)}}{\sum_{\mathbf{M}_j^{(n)} \in \mathcal{M}_a}~p_j^{(n)}}.\]</p><p>The information entropy associated with the probability distribution of microstates in the class <span>$\mathcal{M}_a$</span> is then defined as</p><p class="math-container">\[\xi_a(\varepsilon) \stackrel{\mathrm{def}}{=} -\sum_{\mathbf{M}_i^{(n)} \in \mathcal{M}_a} p_i^{(a, n)} \ln p_i^{(a, n)}.\]</p><p>This entropy is normalized by <span>$\ln m_a$</span>, where <span>$m_a$</span> is the number of microstates in the class <span>$\mathcal{M}_a$</span>. Using RecurrenceMicrostatesAnalysis.jl, the normalized quantity <span>$\xi_a(\varepsilon) / \ln m_a$</span> can be computed as</p><pre><code class="language-julia hljs">using Distributions, RecurrenceMicrostatesAnalysis
data = StateSpaceSet(rand(Uniform(0, 1), 1000))
dist = distribution(data, 0.27, 4; sampling = Full())

class = 102
measure(Disorder(4), class, dist)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.9834268215207178</code></pre><p>The total entropy over all classes for a given threshold <span>$\varepsilon$</span> is defined as</p><p class="math-container">\[\xi(\varepsilon) \stackrel{\mathrm{def}}{=} \frac{1}{A} \sum_{a = 1}^A \frac{\xi_a(\varepsilon)}{\ln m_a},\]</p><p>where <span>$A$</span> is the number of contributing classes and defines the maximum possible amplitude. This normalization factor can also be computed using RecurrenceMicrostatesAnalysis.jl:</p><pre><code class="language-julia hljs">A = RecurrenceMicrostatesAnalysis.get_disorder_norm_factor(Disorder(4), data)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">145</code></pre><p>And the total entropy:</p><pre><code class="language-julia hljs">measure(Disorder(4), dist, A)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.9678965081769859</code></pre><p>Finally, the the <em>disorder index via symmetry in recurrence microstates</em> (DISREM), or simply <strong>disorder</strong>, is defined as</p><p class="math-container">\[\Xi = \max_{\varepsilon} \xi(\varepsilon).\]</p><p>In RecurrenceMicrostatesAnalysis.jl, this quantifier is implemented by the <a href="#Disorder"><code>Disorder</code></a> struct.</p><article><details class="docstring" open="true"><summary id="RecurrenceMicrostatesAnalysis.Disorder"><a class="docstring-binding" href="#RecurrenceMicrostatesAnalysis.Disorder"><code>RecurrenceMicrostatesAnalysis.Disorder</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Disorder{N} &lt;: QuantificationMeasure</code></pre><p>Defines the <em>Disorder</em> quantifier for microstates of size <code>N</code>. The structure contains the <code>labels</code>, which identify the microstates belonging to each equivalence class <span>$\mathcal{M}_a$</span>.</p><p>To initialize the <em>Disorder</em> struct, use:</p><pre><code class="language-julia hljs">Disorder(N)</code></pre><p>Here, <span>$N$</span> must be equal to 2, 3, 4, or 5. Computing disorder for large values of <span>$N$</span> is currently not supported, as it would require a prohibitive amount of computational memory with the current implementation.</p><p>The computation of <em>Disorder</em> is performed using the <a href="#RecurrenceMicrostatesAnalysis.measure"><code>measure</code></a> function:</p><pre><code class="language-julia hljs">measure(settings::Disorder{N}, [x]; kwargs...)</code></pre><p><strong>Input</strong></p><ul><li>The <code>QuantificationMeasure</code>.</li><li><code>[x]</code>: time-series data provided as a <a href="../../#StateSpaceSets.StateSpaceSet"><code>StateSpaceSet</code></a>.</li></ul><p><strong>Output</strong></p><p>Returns a <code>Float64</code> corresponding to the disorder value (<span>$\Xi$</span>).</p><p><strong>Keyword arguments</strong></p><ul><li><code>th</code>: threshold value used to maximize disorder. To improve computational performance, this parameter defines a reference value that limits the search range of thresholds. By default, it is set to the threshold that maximizes disorder for a sampling rate of <span>$5%$</span>.</li><li><code>th_min</code>: minimum threshold value defining the search range. By default, this is set to <code>0.85 * th</code>.</li><li><code>th_max</code>: maximum threshold value defining the search range. By default, this is set to <code>1.25 * th</code>.</li><li><code>num_tests</code>: number of threshold values evaluated within the specified range. The default value is <code>40</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using RecurrenceMicrostatesAnalysis, Distributions
data = StateSpaceSet(rand(Uniform(0, 1), 1000))
disrem = measure(Disorder(4), data)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gabriel-ferr/RecurrenceMicrostatesAnalysis.jl/blob/acaff7c874cf44650b7bd32f7da79eab9cd6199b/src/rqa/disorder.jl#L6-L41">source</a></section></details></article><h3 id="Computing-disorder-for-compatible-time-series"><a class="docs-heading-anchor" href="#Computing-disorder-for-compatible-time-series">Computing disorder for compatible time series</a><a id="Computing-disorder-for-compatible-time-series-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-disorder-for-compatible-time-series" title="Permalink"></a></h3><p>Consider a scenario in which a long time series is split into multiple windows. RecurrenceMicrostatesAnalysis.jl provides a compact interface to compute the disorder for each window.</p><p>As an example, consider a time series with 50,000 points consisting of a sine wave with added white noise, alternating every five windows:</p><pre><code class="language-julia hljs">function data_gen(t)
    x = sin.(6*π .* t)

    count = 0
    for i in 1:1000:50_000
        if count &lt; 5
            x[i:(i-1)+1000] .+= rand(Normal(0, 0.25), 1000)
        elseif count ≥ 9
            count = -1
        end

        count += 1
    end

    return x
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">data_gen (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">using CairoMakie

t = range(0, 50, 50_000)
data = data_gen(t)

lines(t, data)</code></pre><img src="3818952f.png" alt="Example block output"/><p>The disorder can be computed using the following method:</p><pre><code class="language-julia hljs">measure(settings::Disorder{N}, dataset::Vector{StateSpaceSet}, th_min::Float64, th_max::Float64)</code></pre><p>To apply it, the time series must first be split into a vector of <a href="../../#StateSpaceSets.StateSpaceSet"><code>StateSpaceSet</code></a> objects:</p><pre><code class="language-julia hljs">windows = [ data[(i + 1):(i + 1000)] for i in 0:1000:(length(data) - 1000)]
dataset = Vector{StateSpaceSet}(undef, length(windows))
for i ∈ eachindex(windows)
    dataset[i] = StateSpaceSet(windows[i])
end

dataset</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">50-element Vector{StateSpaceSet}:
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 ⋮
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points
 1-dimensional StateSpaceSet{Float64} with 1000 points</code></pre><p>Next, the threshold range <code>th_min</code> and <code>th_max</code> must be defined. There are two possible approaches:</p><ol><li><p>Use the full range of admissible threshold values by setting <code>th_min = 0</code> and <code>th_max = maximum(pairwise(Euclidean(), data, data))</code>, and choosing a small step size via the <code>num_tests</code> keywork argument (e.g., <code>num_tests = 1000</code>). This approach yields the global maximum disorder values but can be computationally expensive.</p></li><li><p>Use a small interval centered around a known threshold value. This is the recommended approach and is adopted here.</p></li></ol><p>To obtain a suitable reference threshold, we select a subset of windows and compute the optimal disorder threshold using the <a href="../utils/#RecurrenceMicrostatesAnalysis.optimize"><code>optimize</code></a> function:</p><pre><code class="language-julia hljs">using Statistics

function find_threshold(disorder, data)
    ths = zeros(Float64, 10)
    for i ∈ eachindex(ths)
        idx = rand(1:length(windows))
        ths[i] = optimize(Threshold(), disorder, data[idx])[1]
    end

    μ = mean(ths)
    σ = std(ths)

    return (max(0.0, μ - 1.5 * σ), μ + 1.5 * σ)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">find_threshold (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">dis = Disorder(4)
th_min, th_max = find_threshold(dis, dataset)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.08804275109809673, 0.7798455072220594)</code></pre><p>Finally, the disorder can be computed for all windows using the <a href="#RecurrenceMicrostatesAnalysis.measure"><code>measure</code></a> function:</p><pre><code class="language-julia hljs">results = measure(dis, dataset, th_min, th_max)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">50-element Vector{Float32}:
 0.9552978
 0.9569975
 0.95214725
 0.9549994
 0.95704657
 0.07926164
 0.07883451
 0.078675084
 0.07884603
 0.07873601
 ⋮
 0.9502808
 0.95399797
 0.95022136
 0.9541418
 0.07931712
 0.07871201
 0.07866802
 0.07870267
 0.078770414</code></pre><pre><code class="language-julia hljs">scatterlines(results)</code></pre><img src="0b556fb4.png" alt="Example block output"/><div class="admonition is-success" id="Tip-325cc7a89d7e0d71"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-325cc7a89d7e0d71" title="Permalink"></a></header><div class="admonition-body"><p>Disorder can also be computed using the <a href="../gpu/#GPU"><code>GPU</code></a> backend:</p><pre><code class="language-julia hljs">measure(settings::Disorder{N}, dataset::Vector{&lt;:AbstractGPUVector{SVector{D, Float32}}}, th_min::Float32, th_max::Float32)</code></pre><p>The procedure is identical, but each window must first be transferred to the GPU:</p><pre><code class="language-julia hljs">for i ∈ eachindex(windows)
    dataset[i] = StateSpaceSet(Float32.(windows[i])) |&gt; CuVector
end</code></pre></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../distributions/">« Distributions</a><a class="docs-footer-nextpage" href="../operations/">Operations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 23 December 2025 17:52">Tuesday 23 December 2025</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
